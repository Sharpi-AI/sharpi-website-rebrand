---

---

<div
  class="relative w-full h-full rounded-[20px] overflow-hidden bg-gradient-to-r from-[#f5f5f5] to-[#f5f5f5]"
  id="quotes-container"
>
  <!-- Background with subtle pattern -->
  <div
    class="absolute inset-0 pointer-events-none"
    aria-hidden="true"
    style="background-image: linear-gradient(90deg, rgb(198, 211, 215) 0%, rgb(198, 211, 215) 100%); opacity: 0.1;"
  >
  </div>

  <!-- Main Content -->
  <div
    class="relative  w-full h-full flex flex-col md:flex-row gap-0 md:gap-0 items-center justify-between md:justify-center p-8 "
  >
    <!-- Left Panel: Message List -->
    <div
      class="relative  z-10 w-full md:w-[430px] flex flex-col gap-[6px] items-center md:items-end"
    >
      <!-- Message 1: Long request -->
      <div
        class="relative bg-white border-[0.5px] border-[rgba(0,0,0,0.12)] rounded-lg px-4 py-3 flex items-center justify-between h-[40px] w-[280px] md:w-[328px]"
        data-message="1"
        data-animated
      >
        <p
          class="text-[11px] text-[#343434] tracking-[-0.22px] leading-[0.9]"
        >
          Me manda uma cotação desses produtos:
        </p>
       
        <div class="bg-[#573DFF] size-1.5 rounded-full absolute top-full right-[49%] md:top-1/2 -translate-y-1/2 md:right-0 translate-x-1/2  block" data-blue-dot data-animated />
      </div>

      <!-- Message 2: Rice -->
      <div
        class="relative bg-white border-[0.5px] border-[rgba(0,0,0,0.12)] rounded-lg px-4 py-3 flex items-center justify-between h-[40px] w-[195px] md:w-[268px]"
        data-message="2"
        data-animated
      >
        <p
          class="text-[11px] text-[#343434] tracking-[-0.22px] leading-[0.9]"
        >
          6 caixas de pilhas AA alcalinas
        </p>

        <div class="bg-[#573DFF] size-1.5 rounded-full absolute top-1/2 -translate-y-1/2 right-0 translate-x-1/2 hidden md:block" data-blue-dot data-animated />

      </div>

      <!-- Message 3: Castanha -->
      <div
        class="relative bg-white border-[0.5px] border-[rgba(0,0,0,0.12)] rounded-lg px-4 py-3 flex items-center justify-between h-[40px] w-[195px] md:w-[268px]"
        data-message="3"
        data-animated
      >
        <p
          class="text-[11px] text-[#343434] tracking-[-0.22px] leading-[0.9]"
        >
        18 rolos filme pvc 10 mts
        </p>

        <div class="bg-[#573DFF] size-1.5 rounded-full absolute top-1/2 -translate-y-1/2 right-0 translate-x-1/2 hidden md:block" data-blue-dot data-animated />

      </div>

      <!-- Message 4: Detergente + User Info -->
      <div class="relative flex flex-col gap-2 items-start" data-message="4" data-animated>
        <div
          class="relative bg-white border-[0.5px] border-[rgba(0,0,0,0.12)] rounded-lg px-4 py-3 flex items-center justify-between h-[40px] w-[195px] md:w-[268px]"
        >
          <p
            class="text-[11px] text-[#343434] tracking-[-0.22px] leading-[0.9]"
          >
          2 galões de água sanitária 5lt
          </p>


          <div class="bg-[#573DFF] size-1.5 rounded-full absolute top-1/2 -translate-y-1/2 right-0 translate-x-1/2 hidden md:block" data-blue-dot data-animated />
        </div>

        <div class="absolute -bottom-6 left-0 flex gap-1 items-center px-4">
          <div class="size-4 rounded-full overflow-hidden shrink-0 bg-gray-300">
            <img
              src="/assets/medias/index/how-to/products/avatar-user.png"
              alt="Fernando Arão"
              class="w-full h-full object-cover"
            />
          </div>
          <span
            class="text-[9px] text-[#3a3a3a] tracking-[-0.18px] leading-[1.33] whitespace-nowrap"
          >
            Fernando Arão
          </span>
          <span
            class="text-[9px] text-[#747474] tracking-[-0.18px] leading-[1.33]"
          >
            1 min atrás
          </span>
        </div>
      </div>
    </div>


    <!-- Flow Animation -->
    <div id="flow" class="hidden md:flex items-center gap-0" data-animated>
      <!-- Left vertical paths group -->
      <div class="flex flex-col gap-0">
        <!-- Flow 1 -->
        <div class="relative translate-y-11.25" data-flow="1">
          <svg class="block" width="153" height="85.5" viewBox="0 0 306 171" fill="none" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg">
            <path id="flow-path-1" d="M 0 1.0811 L 259.369 1.0811 C 272.972 1.0811 284 12.1089 284 25.7123 V 118 C 284 125 295 133 306 133" stroke="none"/>
          </svg>
        </div>

        <!-- Flow 2 -->
        <div class="relative translate-y-1.25" data-flow="2">
          <svg class="block" width="154" height="31" viewBox="0 0 308 62" fill="none" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg">
            <path id="flow-path-2" d="M 0.4629 0.8398 L 259.381 1.8282 C 272.947 1.88 283.918 12.8925 283.918 26.4593 V 26 C 284 38 302 48 309 44" stroke="none"/>
          </svg>
        </div>

        <!-- Flow 3 -->
        <div class="relative -translate-y-2" data-flow="3">
          <svg class="block" width="153" height="32" viewBox="0 0 306 64" fill="none" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg">
            <path id="flow-path-3" d="M 0.4629 58.0703 C 117.085 58.0703 215.408 58.3023 259.358 58.4254 C 272.994 58.4635 284 47.4204 284 33.7838 V 33 C 284 20 293 13 304 13" stroke="none"/>
          </svg>
        </div>

        <!-- Flow 4 -->
        <div class="relative  -translate-y-12" data-flow="4">
          <svg class="block" width="154" height="82.5" viewBox="0 0 308 165" fill="none" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg">
            <path id="flow-path-4" d="M 0 163.566 L 258.369 163.566 C 271.972 163.566 283 152.539 283 138.935 V 61 C 283 51 293 31 307 30" stroke="none"/>
          </svg>
        </div>
      </div>

      <!-- Right horizontal path -->
      <div class="relative" data-flow="5">
        <video src="/assets/medias/index/quotes/particles.webm" class="size-24 absolute -left-12 top-1/2 -translate-y-1/2 object-cover" muted playsinline data-video />
        <svg class="block" width="164"  viewBox="0 0 468 3" fill="none" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg">
          <path id="flow-path-5" d="M0 1.41895H467.69" stroke="none"/>
        </svg>
      </div>
    </div>

    <div id="flow-mobile" class="absolute z-0 top-16 flex  flex-col gap-0 md:hidden">
      <div class="relative " data-flow="1">
        <video src="/assets/medias/index/quotes/particles.webm" style="min-width: 64px; width: 64px; height: 64px; " class="absolute left-0 top-full -translate-x-[40%]  -translate-y-[50%] object-cover mix-blend-darken"  muted playsinline data-video />

        <svg class="block h-[210px] mr-1" width="5" height="210" viewBox="0 0 5 210" fill="none" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg" data-dot-count="5" data-duration="2" data-dot-spacing="150">
          <path id="flow-path-mobile-1" d="M 5 0 L 5 210" stroke=""/>
        </svg>
      </div>
      <div class="relative " data-flow="2">
        <svg class="block h-[60px] mr-1" width="5" height="60" viewBox="0 0 5 60" fill="none" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg" data-dot-count="5" data-duration="1" data-dot-spacing="150">
          <path id="flow-path-mobile-2" d="M 5 0 L 5 60" stroke="none"/>
        </svg>
      </div>
    </div>

    
    <!-- Right Panel: Quote Card + Action Card -->
    <div
      class="relative z-10 flex mb-32  md:mb-0 flex-col md:flex-row items-center gap-4 md:gap-0 w-full md:w-auto"
      data-quote-card
      data-animated
    >
      <div
        class="relative bg-[#d5e5ff] h-[303px] w-[229px] rounded-[12px] shadow-[0px_0px_20px_0px_rgba(0,0,0,0.05)] "
      >
      <div class="bg-[#573DFF] size-1.5 rounded-full absolute top-1/2 -translate-y-1/2 left-0 -translate-x-1/2 hidden md:block" data-blue-dot data-animated />
        <!-- Close Icon -->
        <div class="absolute right-3 top-3 size-2 rounded-full bg-[#8679FF]">
          
        </div>

        <!-- Header -->
        <div
          class="absolute left-[17px] top-[28px] -translate-y-1/2 font-medium text-[14px] text-[#3a3939] tracking-[-0.28px] leading-5"
        >
          Orçamento
        </div>

        <!-- Separator Line -->
        <div class="absolute left-[17px] right-[17px] top-[138px] h-[0.6px] bg-[rgba(0,0,0,0.12)]"></div>

        <!-- Supplier Name -->
        <div
          class="absolute left-[17px] top-[124.5px] -translate-y-1/2 font-medium text-[10px] text-[#3a3a3a] tracking-[-0.2px]"
        >
          Mantiqueira Foods
        </div>

        <!-- Product List -->
        <div
          class="absolute left-[17px] right-[17px] top-[150px] flex flex-col gap-[15px]"
        >
          <!-- Product 1: Farinha de Trigo -->
          <div class="grid grid-cols-[1fr_25%_10%] items-center justify-between">
            <span
              class="text-[8px] text-[#3a3939] tracking-[-0.16px]"
            >
              Farinha de Trigo
            </span>
            <span
              class="text-[8px] text-[#3a3939] tracking-[-0.16px]"
            >
              4 und
            </span>
            <span
              class="text-[8px] text-[#3a3939] tracking-[-0.16px]"
            >
              R$00
            </span>
          </div>

          <!-- Product 2: Ovos Vermelhos -->
          <div class="grid grid-cols-[1fr_25%_10%] items-center justify-between">
            <span
              class="text-[8px] text-[#3a3939] tracking-[-0.16px]"
            >
              Ovos Vermelhos
            </span>
            <span
              class="text-[8px] text-[#3a3939] tracking-[-0.16px]"
            >
              4 und
            </span>
            <span
              class="text-[8px] text-[#3a3939] tracking-[-0.16px]"
            >
              R$00
            </span>
          </div>

          <!-- Product 3: Manteiga -->
          <div class="grid grid-cols-[1fr_25%_10%] items-center justify-between">
            <span
              class="text-[8px] text-[#3a3939] tracking-[-0.16px]"
            >
              Manteiga
            </span>
            <span
              class="text-[8px] text-[#3a3939] tracking-[-0.16px]"
            >
              4 und
            </span>
            <span
              class="text-[8px] text-[#3a3939] tracking-[-0.16px]"
            >
              R$00
            </span>
          </div>

          <!-- Product 4: Arroz Árborio -->
          <div class="grid grid-cols-[1fr_25%_10%] items-center justify-between">
            <span
              class="text-[8px] text-[#3a3939] tracking-[-0.16px]"
            >
              Arroz Árborio
            </span>
            <span
              class="text-[8px] text-[#3a3939] tracking-[-0.16px]"
            >
              4 und
            </span>
            <span
              class="text-[8px] text-[#3a3939] tracking-[-0.16px]"
            >
              R$00
            </span>
          </div>
        </div>

        <!-- Total -->
        <div
          class="absolute bottom-[23px] left-[17px] right-[17px] flex items-end justify-between"
        >
          <span
            class="text-[10px] text-[#3a3939] tracking-[-0.2px]"
          >
            Total:
          </span>
          <span
            class="text-[14px] text-[#3a3939] tracking-[-0.28px] font-medium"
          >
            R$ 190,00
          </span>
        </div>
      </div>

      <div
        class="absolute -bottom-12 left-1/2 -translate-x-1/2 md:bottom-auto md:left-0 md:relative md:-translate-x-1/2 bg-neutral-50 border-[0.5px] border-[rgba(0,0,0,0.12)] rounded-[16px] p-[19px] md:p-3 flex flex-col gap-4 items-center w-[280px] md:w-[113px]"
        data-action-card
        data-animated
      >
        <div class="flex flex-col gap-[6px] items-center text-center">
          <span
            class="text-[13px] md:text-[8px] text-[#8679ff] tracking-[-0.16px] leading-[0.9]"
          >
            Gerado por IA:
          </span>
          <p
            class="text-[19px] md:text-[12px] text-[#343434] tracking-[-0.24px] leading-[0.9]"
          >
            Seu orçamento está pronto!
          </p>
        </div>

        
        <button
          class="bg-[#4a2df6] w-fit rounded-[6px] px-2 py-[6px] flex items-center justify-center gap-1 md:w-full hover:bg-[#3d25d1] transition-colors"
        >
          <span
            class="text-[6px] text-white tracking-[-0.12px] leading-[0.9] text-right whitespace-nowrap"
          >
            Enviar para o cliente
          </span>

          <svg class="size-[7px]" viewBox="0 0 14 17" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M6.5124 16.5789C6.69242 16.7589 6.9203 16.8489 7.19831 16.8489C7.48202 16.8489 7.71103 16.7589 7.88422 16.5789C8.0631 16.4 8.15312 16.1687 8.15312 15.885L8.15312 5.11413L8.04943 2.28498L7.4672 2.57097L10.3658 5.79094L12.337 7.73478C12.4235 7.82251 12.525 7.89202 12.64 7.94329C12.7562 7.99001 12.8804 8.0128 13.0138 8.0128C13.2735 8.0128 13.4912 7.9262 13.6643 7.75301C13.8375 7.57868 13.9253 7.35877 13.9253 7.09329C13.9253 6.83237 13.8261 6.60107 13.6302 6.39825L7.91043 0.670433C7.81814 0.572444 7.70761 0.497243 7.58 0.44483C7.45923 0.392417 7.33162 0.366211 7.19831 0.366211C7.0707 0.366211 6.9465 0.392417 6.82573 0.44483C6.70381 0.497243 6.59443 0.572444 6.49531 0.670433L0.775571 6.39825C0.579595 6.60107 0.480469 6.83237 0.480469 7.09329C0.480469 7.35877 0.568202 7.57868 0.741389 7.75301C0.914576 7.9262 1.1322 8.0128 1.39198 8.0128C1.52529 8.0128 1.64948 7.99001 1.7657 7.94329C1.88078 7.89202 1.98218 7.82251 2.06878 7.73478L4.03081 5.79094L6.92941 2.57097L6.3563 2.28498L6.25261 5.11413L6.25261 15.885C6.25261 16.1687 6.33921 16.4 6.5124 16.5789Z" fill="white" fill-opacity="0.9"/>
            </svg>
            
        </button>
      </div>
    </div>


  </div>
</div>

<style>
  /* Initial states for animated elements */
  [data-message] {
    opacity: 0;
  }

  [data-quote-card] {
    opacity: 0;
  }

  [data-blue-dot] {
    opacity: 0;
  }

  [data-video] {
    opacity: 0;
  }
 

  [data-action-card] {
    opacity: 0;
  }
</style>

<script>
  import { animate, stagger, inView } from "motion"

  // ========================================
  // Animation Speed Configuration
  // ========================================
  // Increase FLOW_SPEED_MULTIPLIER to make animations faster
  // Decrease to make them slower (e.g., 0.5 for half speed, 2 for double speed)
  const FLOW_SPEED_MULTIPLIER = 2
  const BASE_VELOCITY = 20
  const BASE_DELAY_BETWEEN_DOTS = 250

  // ========================================
  // Visibility Control Variables
  // ========================================
  let isTabVisible = !document.hidden
  let isSectionInView = false

  // Detect if viewport is mobile
  function isMobile(): boolean {
    return window.innerWidth < 768
  }

  // Variable to track if animation is running
  let isAnimationRunning = false
  let animationTimeout: ReturnType<typeof setTimeout> | null = null

  // Track active marquees to allow cancellation
  let activeMarquees: PathMarquee[] = []

  // Track active Motion animations to allow cancellation
  let activeMotionAnimations: any[] = []

  function cancelAllMotionAnimations() {
    activeMotionAnimations.forEach((animation) => {
      try {
        animation.stop()
      } catch (error) {
        // Animation might already be stopped
      }
    })
    activeMotionAnimations.length = 0

    // Force reset all animated elements to initial state
    const container = document.getElementById('quotes-container')
    if (!container) return

    const messages = container.querySelectorAll('[data-message]')
    const quoteCard = container.querySelector('[data-quote-card]')
    const actionCard = container.querySelector('[data-action-card]')
    const blueDots = container.querySelectorAll('[data-blue-dot]')

    messages.forEach((el) => {
      const element = el as HTMLElement
      element.style.opacity = ''
      element.style.transform = ''
    })

    if (quoteCard) {
      const element = quoteCard as HTMLElement
      element.style.opacity = ''
      element.style.transform = ''
    }

    if (actionCard) {
      const element = actionCard as HTMLElement
      element.style.opacity = ''
      element.style.transform = ''
    }

    blueDots.forEach((el) => {
      const element = el as HTMLElement
      element.style.opacity = ''
    })

    // Reset videos
    const videos = container.querySelectorAll('[data-video]') as NodeListOf<HTMLVideoElement>
    videos.forEach((video) => {
      video.style.opacity = ''
    })
  }

  // Debounce control for visibility checks
  let visibilityCheckTimeout: ReturnType<typeof setTimeout> | null = null
  let isStopping = false

  // Flow animation with Promise-based completion
  class PathMarquee {
    container: HTMLElement
    pathId: string
    dotCount: number
    velocity: number
    startDelay: number
    dotSpacing?: number
    onFirstDotComplete?: () => void
    dots: HTMLDivElement[]
    completionPromise: (() => void) | null = null
    animationFrameIds: number[]
    timeoutIds: ReturnType<typeof setTimeout>[]
    isStopped: boolean

    constructor(container: HTMLElement, pathId: string, dotCount: number, velocity: number, startDelay = 0, dotSpacing?: number, onFirstDotComplete?: () => void) {
      this.container = container
      this.pathId = pathId
      this.dotCount = dotCount
      this.velocity = velocity
      this.startDelay = startDelay
      this.dotSpacing = dotSpacing
      this.onFirstDotComplete = onFirstDotComplete
      this.dots = []
      this.animationFrameIds = []
      this.timeoutIds = []
      this.isStopped = false
    }

    start() {
      // Register this marquee as active
      activeMarquees.push(this)

      return new Promise<void>((resolve) => {
        this.completionPromise = () => resolve()
        const timeoutId = setTimeout(() => this.init(), this.startDelay)
        this.timeoutIds.push(timeoutId)
      })
    }

    init() {
      if (this.isStopped) return

      const path = this.container.querySelector(`#${this.pathId}`)
      if (!path) return

      const pathLength = (path as SVGPathElement).getTotalLength()

      // Calculate SVG scale factor (viewport size / viewBox size)
      const svg = (path as SVGPathElement).ownerSVGElement
      if (!svg) return
      const scale = svg.width.baseVal.value / svg.viewBox.baseVal.width

      // Get wrapper element
      const wrapper = path.closest('[data-flow]')
      if (!wrapper) return

      // Create dots
      for (let i = 0; i < this.dotCount; i++) {
        const dot = document.createElement('div')
        dot.className = 'flow-dot'
        dot.style.position = 'absolute'
        dot.style.width = '3px'
        dot.style.height = '3px'
        dot.style.background = '#573DFF'
        dot.style.borderRadius = '50%'
        dot.style.top = '0'
        dot.style.left = '0'
        dot.style.opacity = '0'
        dot.style.pointerEvents = 'none'

        wrapper.appendChild(dot)
        this.dots.push(dot)
      }

      // Calculate timing (adjusted by speed multiplier)
      const travelTime = (100 / this.velocity) * 1000
      const delayBetweenDots = this.dotSpacing !== undefined ? this.dotSpacing : (BASE_DELAY_BETWEEN_DOTS / FLOW_SPEED_MULTIPLIER)

      let completedDots = 0
      const totalDots = this.dotCount
      let firstDotCallbackFired = false

      // Animate each dot
      this.dots.forEach((dot: HTMLDivElement, index: number) => {
        const dotDelay = index * delayBetweenDots

        // Schedule callback to fire 500ms before first dot completes
        if (index === 0 && this.onFirstDotComplete) {
          const callbackTiming = Math.max(0, dotDelay + travelTime - 500)
          const callbackTimeoutId = setTimeout(() => {
            if (!this.isStopped && !firstDotCallbackFired && this.onFirstDotComplete) {
              firstDotCallbackFired = true
              this.onFirstDotComplete()
            }
          }, callbackTiming)
          this.timeoutIds.push(callbackTimeoutId)
        }

        const timeoutId = setTimeout(() => {
          if (this.isStopped) return

          this.animateDot(dot, path as SVGPathElement, travelTime, pathLength, scale, () => {
            completedDots++
            // When all dots complete, resolve the promise
            if (completedDots === totalDots && this.completionPromise) {
              this.completionPromise()
            }
          })
        }, dotDelay)
        this.timeoutIds.push(timeoutId)
      })
    }

    animateDot(dot: HTMLDivElement, path: SVGPathElement, duration: number, pathLength: number, scale: number, onComplete: () => void) {
      if (this.isStopped) return

      dot.style.opacity = '1'

      let startTime: number | null = null

      const animateFrame = (timestamp: number) => {
        // Check if stopped
        if (this.isStopped) {
          dot.style.opacity = '0'
          return
        }

        if (!startTime) startTime = timestamp
        const elapsed = timestamp - startTime
        const progress = Math.min(elapsed / duration, 1)

        if (progress < 1) {
          const distance = progress * pathLength
          const point = path.getPointAtLength(distance)

          // Apply scale factor to match SVG viewport size
          dot.style.transform = `translate(${point.x * scale}px, ${point.y * scale}px)`

          const frameId = requestAnimationFrame(animateFrame)
          this.animationFrameIds.push(frameId)
        } else {
          dot.style.opacity = '0'
          if (onComplete) onComplete()
        }
      }

      const frameId = requestAnimationFrame(animateFrame)
      this.animationFrameIds.push(frameId)
    }

    stop() {
      this.isStopped = true

      // Cancel all requestAnimationFrame
      this.animationFrameIds.forEach((id) => cancelAnimationFrame(id))
      this.animationFrameIds = []

      // Clear all timeouts
      this.timeoutIds.forEach((id) => clearTimeout(id))
      this.timeoutIds = []

      // Hide all dots
      this.dots.forEach((dot: HTMLDivElement) => {
        dot.style.opacity = '0'
      })
    }

    cleanup() {
      // Stop animations first
      this.stop()

      // Remove all dots from DOM
      this.dots.forEach((dot: HTMLDivElement) => dot.remove())
      this.dots = []

      // Remove from active marquees
      const index = activeMarquees.indexOf(this)
      if (index > -1) {
        activeMarquees.splice(index, 1)
      }
    }
  }

  // Start mobile flow animation (vertical)
  // Sequence: Flow 1 → Video → Flow 2
  async function startMobileFlowAnimation(onFlow2FirstDotComplete?: () => void) {
    // Get mobile flow container
    const mobileFlowContainer = document.getElementById('flow-mobile')
    if (!mobileFlowContainer) return

    // ========================================
    // STEP 1: Start first vertical flow and wait for completion
    // ========================================
    // Read attributes from SVG
    const svg1 = mobileFlowContainer.querySelector('[data-flow="1"] svg') as SVGSVGElement
    const dotCount1 = svg1 ? Number.parseInt(svg1.getAttribute('data-dot-count') || '15', 10) : 15
    const duration1 = svg1 ? Number.parseFloat(svg1.getAttribute('data-duration') || '2') : 2
    const dotSpacing1 = svg1 ? Number.parseInt(svg1.getAttribute('data-dot-spacing') || '150', 10) : 150

    // Calculate velocity from duration: velocity = 100 / duration
    const velocity1 = 100 / duration1

    const marquee1 = new PathMarquee(mobileFlowContainer, 'flow-path-mobile-1', dotCount1, velocity1, 0, dotSpacing1)
    await marquee1.start()

    // ========================================
    // STEP 2: Play video after first flow completes
    // ========================================
    const video = mobileFlowContainer.querySelector('[data-video]') as HTMLVideoElement

    if (video) {
      await new Promise<void>((resolve) => {
        const fadeInAnim = animate(video, { opacity: [0, 1] }, { duration: 0.5 })
        activeMotionAnimations.push(fadeInAnim)
        video.currentTime = 0
        video.playbackRate = 1.8
        video.play()

        video.addEventListener('ended', () => {
          const fadeOutAnim = animate(video, { opacity: 0 }, { duration: 0.5 })
          activeMotionAnimations.push(fadeOutAnim)
          resolve()
        }, { once: true })
      })
    }

    // ========================================
    // STEP 3: Start second vertical flow after video ends
    // ========================================
    // Read attributes from SVG
    const svg2 = mobileFlowContainer.querySelector('[data-flow="2"] svg') as SVGSVGElement
    const dotCount2 = svg2 ? Number.parseInt(svg2.getAttribute('data-dot-count') || '10', 10) : 10
    const duration2 = svg2 ? Number.parseFloat(svg2.getAttribute('data-duration') || '1') : 1
    const dotSpacing2 = svg2 ? Number.parseInt(svg2.getAttribute('data-dot-spacing') || '150', 10) : 150

    // Calculate velocity from duration: velocity = 100 / duration
    const velocity2 = 100 / duration2

    const marquee2 = new PathMarquee(mobileFlowContainer, 'flow-path-mobile-2', dotCount2, velocity2, 0, dotSpacing2, onFlow2FirstDotComplete)
    await marquee2.start()

    // ========================================
    // Cleanup
    // ========================================
    marquee1.cleanup()
    marquee2.cleanup()
  }

  // Mobile timeline function
  // async function playMobileTimeline() {
  //   const container = document.getElementById('quotes-container')
  //   if (!container) return

  //   isAnimationRunning = true

  //   // Get all elements
  //   const messages = container.querySelectorAll('[data-message]')
  //   const quoteCard = container.querySelector('[data-quote-card]')
  //   const actionCard = container.querySelector('[data-action-card]')
  //   const animatedElements = container.querySelectorAll('[data-animated]')

  //   // Phase 1: Messages appear in center with fade-in up and stagger
  //   // Step 1a: Appear in center with fade-in up (start 20px below center, rise to center)
  //   await animate(
  //     messages,
  //     { opacity: [0, 1], y: [170, 150] },
  //     { delay: stagger(0.15), duration: 0.8, ease: "easeOut" }
  //   ).finished

  //   // Step 1b: Move from center to final position
  //   await animate(
  //     messages,
  //     { y: [150, 0] },
  //     { duration: 1.2, ease: [0.22, 1, 0.36, 1] }
  //   ).finished

  //   // Phase 3: Blue dot from first message appears (mobile only has one visible blue dot)
  //   const blueDotMobile = container.querySelector('[data-message="1"] [data-blue-dot]')
  //   if (blueDotMobile) {
  //     await animate(
  //       blueDotMobile,
  //       { opacity: [0, 1] },
  //       { duration: 0.6, ease: "easeOut" }
  //     ).finished
  //   }

  //   // Phase 4: Flow animation (vertical) + video
  //   // Quote card appears when first dot of flow 2 completes
  //   await startMobileFlowAnimation(() => {
  //     if (quoteCard) {
  //       animate(
  //         quoteCard,
  //         { opacity: [0, 1] },
  //         { duration: 0.8, ease: "easeOut" }
  //       )
  //     }
  //   })

  //   // Phase 5: Action card appears
  //   if (actionCard) {
  //     await animate(
  //       actionCard,
  //       { opacity: [0, 1], y: [20, 0] },
  //       { duration: 0.6, ease: "easeOut" }
  //     ).finished
  //   }

  //   // Wait 3 seconds with everything visible
  //   await new Promise(resolve => setTimeout(resolve, 3000))

  //   // Fade out everything
  //   await animate(
  //     animatedElements,
  //     { opacity: 0 },
  //     { duration: 1.5, ease: "easeIn" }
  //   ).finished

  //   // Reset and restart
  //   animationTimeout = setTimeout(() => {
  //     // Reset opacity for next cycle
  //     messages.forEach((el) => (el as HTMLElement).style.opacity = '0')
  //     if (quoteCard) (quoteCard as HTMLElement).style.opacity = '0'
  //     if (actionCard) (actionCard as HTMLElement).style.opacity = '0'

  //     // Reset blue dot mobile
  //     const blueDotMobile = container.querySelector('[data-message="1"] [data-blue-dot]') as HTMLElement
  //     if (blueDotMobile) blueDotMobile.style.opacity = '0'

  //     // Reset video mobile
  //     const mobileFlowContainer = document.getElementById('flow-mobile')
  //     if (mobileFlowContainer) {
  //       const video = mobileFlowContainer.querySelector('[data-video]') as HTMLVideoElement
  //       if (video) {
  //         video.pause()
  //         video.currentTime = 0
  //         video.style.opacity = '0'
  //       }
  //     }

  //     // Restart timeline
  //     playMobileTimeline()
  //   }, 1000)
  // }
// Mobile timeline function
async function playMobileTimeline() {
    const container = document.getElementById('quotes-container')
    if (!container) return

    cancelAllMotionAnimations()
    activeMarquees.forEach((marquee) => marquee.stop())
    await new Promise((resolve) => setTimeout(resolve, 100))

    isAnimationRunning = true

    const mobileFlowContainer = document.getElementById('flow-mobile')
    if (mobileFlowContainer) mobileFlowContainer.style.opacity = '1'

    const messages = container.querySelectorAll('[data-message]')
    const quoteCard = container.querySelector('[data-quote-card]')
    const actionCard = container.querySelector('[data-action-card]')
    const animatedElements = container.querySelectorAll('[data-animated]')

    const msgAnimation1 = animate(
      messages,
      { opacity: [0, 1], y: [170, 150] },
      { delay: stagger(0.15), duration: 0.8, ease: "easeOut" }
    )
    activeMotionAnimations.push(msgAnimation1)
    await msgAnimation1.finished

    const msgAnimation2 = animate(
      messages,
      { y: [150, 0] },
      { duration: 1.2, ease: [0.22, 1, 0.36, 1] }
    )
    activeMotionAnimations.push(msgAnimation2)
    await msgAnimation2.finished

    const blueDotMobile = container.querySelector('[data-message="1"] [data-blue-dot]')
    if (blueDotMobile) {
      const dotAnimation = animate(
        blueDotMobile,
        { opacity: [0, 1] },
        { duration: 0.6, ease: "easeOut" }
      )
      activeMotionAnimations.push(dotAnimation)
      await dotAnimation.finished
    }

    await startMobileFlowAnimation(() => {
      if (quoteCard) {
        const quoteAnim = animate(
          quoteCard,
          { opacity: [0, 1] },
          { duration: 0.8, ease: "easeOut" }
        )
        activeMotionAnimations.push(quoteAnim)
      }
    })

    if (actionCard) {
      const actionAnimation = animate(
        actionCard,
        { opacity: [0, 1], y: [20, 0] },
        { duration: 0.6, ease: "easeOut" }
      )
      activeMotionAnimations.push(actionAnimation)
      await actionAnimation.finished
    }

    await new Promise(resolve => setTimeout(resolve, 3000))

    const fadeOutAnimation = animate(
      animatedElements,
      { opacity: 0 },
      { duration: 1.5, ease: "easeIn" }
    )
    activeMotionAnimations.push(fadeOutAnimation)
    await fadeOutAnimation.finished

    // Reset and restart
    animationTimeout = setTimeout(() => {
      // Reset opacity for next cycle
      messages.forEach((el) => (el as HTMLElement).style.opacity = '0')
      if (quoteCard) (quoteCard as HTMLElement).style.opacity = '0'
      if (actionCard) (actionCard as HTMLElement).style.opacity = '0'

      // Reset blue dot mobile
      const blueDotMobile = container.querySelector('[data-message="1"] [data-blue-dot]') as HTMLElement
      if (blueDotMobile) blueDotMobile.style.opacity = '0'

      // Reset video mobile
      const mobileFlowContainer = document.getElementById('flow-mobile')
      if (mobileFlowContainer) {
        const video = mobileFlowContainer.querySelector('[data-video]') as HTMLVideoElement
        if (video) {
          video.pause()
          video.currentTime = 0
          video.style.opacity = '0'
        }
        // === NOVO: Reseta a opacidade do contêiner de flow mobile ===
        mobileFlowContainer.style.opacity = '0'
        // =========================================================
      }

      // Restart timeline
      playMobileTimeline()
    }, 1000)
  }


  // Main timeline function
  // async function playTimeline() {
  //   // Run mobile timeline if on mobile
  //   if (isMobile()) {
  //     playMobileTimeline()
  //     return
  //   }

  //   const container = document.getElementById('quotes-container')
  //   if (!container) return

  //   isAnimationRunning = true

  //   // Get all elements
  //   const messages = container.querySelectorAll('[data-message]')
  //   const quoteCard = container.querySelector('[data-quote-card]')
  //   const actionCard = container.querySelector('[data-action-card]')
  //   const blueDots = container.querySelectorAll('[data-blue-dot]')
  //   const animatedElements = container.querySelectorAll('[data-animated]')

  //   // Phase 1: Messages appear in center with fade-in up and stagger
  //   // Step 1a: Appear in center with fade-in up
  //   await animate(
  //     messages,
  //     { opacity: [0, 1], x: [300, 300], y: [20, 0] },
  //     { delay: stagger(0.15), duration: 0.8, ease: "easeOut" }
  //   ).finished

  //   // Step 1b: Move from center to left (final position)
  //   await animate(
  //     messages,
  //     { x: [300, 0] },
  //     { duration: 1.2, ease: [0.22, 1, 0.36, 1] }
  //   ).finished

  //   // Phase 2: Quote card appears from right
  //   if (quoteCard) {
  //     await animate(
  //       quoteCard,
  //       { opacity: [0, 1], x: [40, 0] },
  //       { duration: 1, ease: "easeOut" }
  //     ).finished
  //   }

  //   // Phase 3: Blue dots appear
  //   await animate(
  //     blueDots,
  //     { opacity: [0, 1] },
  //     { duration: 0.6, ease: "easeOut" }
  //   ).finished

  //   // Phase 4: Flow animation
  //   await startFlowAnimation(container)

  //   // Phase 4.5: Action card appears after flow completes
  //   if (actionCard) {
  //     await animate(
  //       actionCard,
  //       { opacity: [0, 1], y: [20, 0] },
  //       { duration: 0.6, ease: "easeOut" }
  //     ).finished
  //   }

  //   // Phase 4.75: Wait 3 seconds with everything visible
  //   await new Promise(resolve => setTimeout(resolve, 3000))

  //   // Phase 5: Fade out everything
  //   await animate(
  //     animatedElements,
  //     { opacity: 0 },
  //     { duration: 1.5, ease: "easeIn" }
  //   ).finished

  //   // Phase 6: Reset and restart
  //   animationTimeout = setTimeout(() => {
  //     // Reset opacity for next cycle - elements that will be animated
  //     messages.forEach((el) => (el as HTMLElement).style.opacity = '0')
  //     if (quoteCard) (quoteCard as HTMLElement).style.opacity = '0'
  //     if (actionCard) (actionCard as HTMLElement).style.opacity = '0'
  //     blueDots.forEach((el) => (el as HTMLElement).style.opacity = '0')

  //     // Reset video
  //     const video = container.querySelector('[data-video]') as HTMLVideoElement
  //     if (video) {
  //       video.currentTime = 0
  //       video.style.opacity = '0'
  //     }

  //     // Reset only flow container (needs to be visible for flow dots)
  //     const flowContainer = container.querySelector('#flow') as HTMLElement
  //     if (flowContainer) flowContainer.style.opacity = '1'

  //     // Restart timeline
  //     playTimeline()
  //   }, 1000)
  // }
// Main timeline function
async function playTimeline() {
    // Run mobile timeline if on mobile
    if (isMobile()) {
      playMobileTimeline()
      return
    }

    const container = document.getElementById('quotes-container')
    if (!container) return

    cancelAllMotionAnimations()
    activeMarquees.forEach((marquee) => marquee.stop())
    await new Promise((resolve) => setTimeout(resolve, 100))

    isAnimationRunning = true

    const flowContainer = container.querySelector('#flow') as HTMLElement
    if (flowContainer) flowContainer.style.opacity = '1'

    const messages = container.querySelectorAll('[data-message]')
    const quoteCard = container.querySelector('[data-quote-card]')
    const actionCard = container.querySelector('[data-action-card]')
    const blueDots = container.querySelectorAll('[data-blue-dot]')
    const animatedElements = container.querySelectorAll('[data-animated]')

    const msgAnimation1 = animate(
      messages,
      { opacity: [0, 1], x: [300, 300], y: [20, 0] },
      { delay: stagger(0.15), duration: 0.8, ease: "easeOut" }
    )
    activeMotionAnimations.push(msgAnimation1)
    await msgAnimation1.finished

    const msgAnimation2 = animate(
      messages,
      { x: [300, 0] },
      { duration: 1.2, ease: [0.22, 1, 0.36, 1] }
    )
    activeMotionAnimations.push(msgAnimation2)
    await msgAnimation2.finished

    if (quoteCard) {
      const quoteAnimation = animate(
        quoteCard,
        { opacity: [0, 1], x: [40, 0] },
        { duration: 1, ease: "easeOut" }
      )
      activeMotionAnimations.push(quoteAnimation)
      await quoteAnimation.finished
    }

    const dotsAnimation = animate(
      blueDots,
      { opacity: [0, 1] },
      { duration: 0.6, ease: "easeOut" }
    )
    activeMotionAnimations.push(dotsAnimation)
    await dotsAnimation.finished

    await startFlowAnimation(container)

    if (actionCard) {
      const actionAnimation = animate(
        actionCard,
        { opacity: [0, 1], y: [20, 0] },
        { duration: 0.6, ease: "easeOut" }
      )
      activeMotionAnimations.push(actionAnimation)
      await actionAnimation.finished
    }

    await new Promise(resolve => setTimeout(resolve, 3000))

    const fadeOutAnimation = animate(
      animatedElements,
      { opacity: 0 },
      { duration: 1.5, ease: "easeIn" }
    )
    activeMotionAnimations.push(fadeOutAnimation)
    await fadeOutAnimation.finished

    

    // Phase 6: Reset and restart
    animationTimeout = setTimeout(() => {
      // Reset opacity for next cycle - elements that will be animated
      messages.forEach((el) => (el as HTMLElement).style.opacity = '0')
      if (quoteCard) (quoteCard as HTMLElement).style.opacity = '0'
      if (actionCard) (actionCard as HTMLElement).style.opacity = '0'
      blueDots.forEach((el) => (el as HTMLElement).style.opacity = '0')

      // Reset video
      const video = container.querySelector('[data-video]') as HTMLVideoElement
      if (video) {
        video.currentTime = 0
        video.style.opacity = '0'
      }

      // === CORRIGIDO: Reseta a opacidade do contêiner de flow para 0 ===
      const flowContainer = container.querySelector('#flow') as HTMLElement
      if (flowContainer) flowContainer.style.opacity = '0' // Estava '1'
      // ===========================================================

      // Restart timeline
      playTimeline()
    }, 1000)
  }

  // Start flow animations and wait for completion
  // Sequence: Left flows → Video → Right flow
  async function startFlowAnimation(container: HTMLElement) {
    const velocity = BASE_VELOCITY * FLOW_SPEED_MULTIPLIER
    const dotCount = 20

    const leftMarquees = []

    // ========================================
    // STEP 1: Create and start flows 1-4 (left side)
    // ========================================
    for (let i = 1; i <= 4; i++) {
      const marquee = new PathMarquee(container, `flow-path-${i}`, dotCount, velocity, 0)
      leftMarquees.push(marquee)
    }

    // Start left flows and wait for all to complete
    await Promise.all(leftMarquees.map(m => m.start()))

    // ========================================
    // STEP 2: Play video and wait for it to finish
    // ========================================
    const video = container.querySelector('[data-video]') as HTMLVideoElement

    if (video) {
      await new Promise<void>((resolve) => {
        const fadeInAnim = animate(video, { opacity: [0, 1] }, { duration: 0.5 })
        activeMotionAnimations.push(fadeInAnim)
        video.currentTime = 0
        video.playbackRate = 1.8
        video.play()

        video.addEventListener('ended', () => {
          const fadeOutAnim = animate(video, { opacity: 0 }, { duration: 0.5 })
          activeMotionAnimations.push(fadeOutAnim)
          resolve()
        }, { once: true })
      })
    }

    // ========================================
    // STEP 3: Start flow 5 (right/horizontal) after video ends
    // ========================================
    const horizontalMarquee = new PathMarquee(container, 'flow-path-5', dotCount, velocity, 0)
    await horizontalMarquee.start()

    // ========================================
    // Cleanup all marquees
    // ========================================
    leftMarquees.forEach(m => m.cleanup())
    horizontalMarquee.cleanup()
  }

  // Handle window resize
  function handleResize() {
    const wasMobile = !isAnimationRunning && isMobile()
    const isNowMobile = isMobile()

    // If switching from desktop to mobile, stop animations
    if (!wasMobile && isNowMobile && isAnimationRunning) {
      isAnimationRunning = false
      if (animationTimeout) {
        clearTimeout(animationTimeout)
        animationTimeout = null
      }
    }

    // If switching from mobile to desktop, start animations
    if (wasMobile && !isNowMobile && !isAnimationRunning) {
      playTimeline()
    }
  }

  // Debounce resize handler
  let resizeTimeout: ReturnType<typeof setTimeout> | null = null
  window.addEventListener('resize', () => {
    if (resizeTimeout) clearTimeout(resizeTimeout)
    resizeTimeout = setTimeout(handleResize, 250)
  })

  // ========================================
  // Stop and reset animation
  // ========================================
  // function stopAnimation() {
  //   // Prevent multiple simultaneous calls
  //   if (isStopping || !isAnimationRunning) return

  //   isStopping = true
  //   isAnimationRunning = false

  //   // Clear any pending timeouts
  //   if (animationTimeout) {
  //     clearTimeout(animationTimeout)
  //     animationTimeout = null
  //   }

  //   // Stop all active marquees (this will cancel all requestAnimationFrame and timeouts)
  //   activeMarquees.forEach((marquee) => marquee.stop())

  //   // Reset all animated elements
  //   const container = document.getElementById('quotes-container')
  //   if (!container) return

  //   const messages = container.querySelectorAll('[data-message]')
  //   const quoteCard = container.querySelector('[data-quote-card]')
  //   const actionCard = container.querySelector('[data-action-card]')
  //   const blueDots = container.querySelectorAll('[data-blue-dot]')

  //   // Reset opacity and transforms
  //   messages.forEach((el) => {
  //     (el as HTMLElement).style.opacity = '0'
  //     ;(el as HTMLElement).style.transform = ''
  //   })
  //   if (quoteCard) {
  //     (quoteCard as HTMLElement).style.opacity = '0'
  //     ;(quoteCard as HTMLElement).style.transform = ''
  //   }
  //   if (actionCard) {
  //     (actionCard as HTMLElement).style.opacity = '0'
  //     ;(actionCard as HTMLElement).style.transform = ''
  //   }
  //   blueDots.forEach((el) => {
  //     (el as HTMLElement).style.opacity = '0'
  //   })

  //   // Reset videos
  //   const videos = container.querySelectorAll('[data-video]') as NodeListOf<HTMLVideoElement>
  //   videos.forEach((video) => {
  //     video.pause()
  //     video.currentTime = 0
  //     video.style.opacity = '0'
  //   })

  //   // Clean up flow dots (already stopped via marquee.stop(), now remove from DOM)
  //   const flowDots = container.querySelectorAll('.flow-dot')
  //   flowDots.forEach((dot) => dot.remove())

  //   // Clear active marquees array
  //   activeMarquees.forEach((marquee) => {
  //     const index = activeMarquees.indexOf(marquee)
  //     if (index > -1) {
  //       activeMarquees.splice(index, 1)
  //     }
  //   })
  //   activeMarquees = []

  //   // Reset stopping flag
  //   isStopping = false
  // }
  // ========================================
  // Stop and reset animation
  // ========================================
  function stopAnimation() {
    if (isStopping || !isAnimationRunning) return

    isStopping = true
    isAnimationRunning = false

    if (animationTimeout) {
      clearTimeout(animationTimeout)
      animationTimeout = null
    }

    cancelAllMotionAnimations()
    activeMarquees.forEach((marquee) => marquee.stop())

    const container = document.getElementById('quotes-container')
    if (!container) return

    const messages = container.querySelectorAll('[data-message]')
    const quoteCard = container.querySelector('[data-quote-card]')
    const actionCard = container.querySelector('[data-action-card]')
    const blueDots = container.querySelectorAll('[data-blue-dot]')

    messages.forEach((el) => {
      (el as HTMLElement).style.opacity = '0'
      ;(el as HTMLElement).style.transform = ''
    })
    if (quoteCard) {
      (quoteCard as HTMLElement).style.opacity = '0'
      ;(quoteCard as HTMLElement).style.transform = ''
    }
    if (actionCard) {
      (actionCard as HTMLElement).style.opacity = '0'
      ;(actionCard as HTMLElement).style.transform = ''
    }
    blueDots.forEach((el) => {
      (el as HTMLElement).style.opacity = '0'
    })

    const flowDesktop = container.querySelector('#flow') as HTMLElement
    const flowMobile = container.querySelector('#flow-mobile') as HTMLElement
    if (flowDesktop) flowDesktop.style.opacity = '0'
    if (flowMobile) flowMobile.style.opacity = '0'

    const videos = container.querySelectorAll('[data-video]') as NodeListOf<HTMLVideoElement>
    videos.forEach((video) => {
      video.pause()
      video.currentTime = 0
      video.style.opacity = '0'
    })

    const flowDots = container.querySelectorAll('.flow-dot')
    flowDots.forEach((dot) => dot.remove())

    activeMarquees = []

    isStopping = false
  }

  // ========================================
  // Check if should play animation (with debounce)
  // ========================================
  function checkAndPlayAnimation() {
    // Clear any pending visibility check
    if (visibilityCheckTimeout) {
      clearTimeout(visibilityCheckTimeout)
      visibilityCheckTimeout = null
    }

    // Debounce to prevent rapid state changes
    visibilityCheckTimeout = setTimeout(() => {
      const shouldPlay = isSectionInView && isTabVisible
      const shouldStop = !shouldPlay && isAnimationRunning

      // Start animation if conditions are met and not already running
      if (shouldPlay && !isAnimationRunning && !isStopping) {
        playTimeline()
      }
      // Stop animation if conditions not met and is running
      else if (shouldStop && !isStopping) {
        stopAnimation()
      }
    }, 100) // 100ms debounce to prevent rapid changes
  }

  // ========================================
  // Page Visibility API - Detect tab changes
  // ========================================
  document.addEventListener('visibilitychange', () => {
    isTabVisible = !document.hidden
    checkAndPlayAnimation()
  })

  // ========================================
  // InView - Detect section visibility
  // ========================================
  const container = document.getElementById('quotes-container')
  if (container) {
    inView(container, () => {
      isSectionInView = true
      checkAndPlayAnimation()

      // Return cleanup function when element leaves viewport
      return () => {
        isSectionInView = false
        checkAndPlayAnimation()
      }
    })
  }
</script>
