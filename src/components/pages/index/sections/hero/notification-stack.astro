---
import NotificationCard from "./notification-card.astro";

const notifications = [
  {
    id: 1,
    title: "Enviado para o ERP",
    message: "250+ pedidos múltiplos",
    media: "/assets/medias/index/hero/analizing.mp4",
    type: "video",
  },
  {
    id: 2,
    title: "Cotação enviada",
    message: "Cliente revisou no whatsapp",
    media: "/assets/medias/index/hero/notification-01.png",
    type: "image",
  },
  {
    id: 3,
    title: "Pedido faturado",
    message: "20xc Leite e mais 13 itens.",
    media: "/assets/medias/index/hero/analizing.mp4",
    type: "video",
  },
  {
    id: 4,
    title: "Pedido faturado",
    message: "+100 pedidos múltiplos",
    media: "/assets/medias/index/hero/notification-02.png",
    type: "image",
  },
];
---

<div id="notification-stack" class="relative w-full md:h-full px-4 py-6">
  <div id="notifications-container" class="h-40 relative flex flex-col-reverse">
    {
      notifications.map((notification, index) => (
        <div
          id={`notification-wrapper-${index}`}
          class="absolute bottom-0 inset-x-0 flex justify-center"
          data-index={index}
          data-id={notification.id}
        >
          <NotificationCard
            title={notification.title}
            message={notification.message}
            media={notification.media}
            type={notification.type as "image" | "video"}
            index={index}
          />
        </div>
      ))
    }
  </div>
</div>

<script>
  // @ts-nocheck
  import { animate, stagger } from "motion";

  function initNotificationAnimation() {
    const container = document.getElementById("notification-stack");
    if (!container) return;

    const wrappers = container.querySelectorAll(
      '[id^="notification-wrapper-"]'
    );
    const cards = container.querySelectorAll('[id^="notification-card-"]');

    // Set initial positions (bottom-to-top approach)
    wrappers.forEach((wrapper: Element, index: number) => {
      const element = wrapper as HTMLElement;
      element.style.transform = `translateY(100px)`; // Start from below
      element.style.opacity = "0";
      element.style.scale = "1";
      element.style.zIndex = "0"; // Will be set during animation
    });

    // Animation sequence functions - bottom-to-top stacking
    async function playNotificationSequence() {
      try {
        // Reset all cards to initial position (below screen)
        await animate(
          wrappers,
          {
            opacity: 0,
            y: 100,
            scale: 1,
          },
          { duration: 0 }
        );

        // Reset opacity of all cards
        wrappers.forEach((wrapper) => {
          const card = wrapper.querySelector(
            '[id^="notification-card-"]'
          ) as HTMLElement;
          if (card) {
            card.style.opacity = "1";
          }
        });

        // Animate each notification one by one
        for (let i = 0; i < wrappers.length; i++) {
          const currentWrapper = wrappers[i] as HTMLElement;

          // Set z-index for proper stacking (newest on top) - higher index = higher z-index
          currentWrapper.style.zIndex = (i + 1).toString();

          // Set full opacity for the current (top) notification
          const currentCard = currentWrapper.querySelector(
            '[id^="notification-card-"]'
          ) as HTMLElement;
          if (currentCard) {
            currentCard.style.backgroundColor = "#FFFFFF";
            currentCard.style.opacity = "1";
          }

          // Animate current notification sliding up from bottom
          await animate(
            currentWrapper,
            {
              opacity: 1,
              y: 0,
              scale: 1,
            },
            {
              duration: 0.5,
              easing: [0.23, 1, 0.32, 1],
            }
          );

          // Push previous notifications up and scale them down
          if (i > 0) {
            const previousNotifications = Array.from(wrappers).slice(0, i);
            await Promise.all(
              previousNotifications.map((wrapper, prevIndex) => {
                const stackLevel = i - prevIndex; // How many levels up
                const stackOffset = -stackLevel * 10; // Reduced from 60px to 25px for subtlety
                const stackScale = Math.max(0.85, 1 - stackLevel * 0.05); // Reduced scaling for subtlety
                const stackOpacity =
                  stackLevel >= 4 ? 0 : Math.max(0, 1 - stackLevel * 0.25); // 5th card (index 4) becomes invisible

                // Set background color with absolute hex opacity
                const element = wrapper as HTMLElement;
                const card = element.querySelector(
                  '[id^="notification-card-"]'
                ) as HTMLElement;
                if (card) {
                  let hexColor = "#FFFFFF00"; // Default transparent
                  if (stackOpacity >= 1) {
                    hexColor = "#FFFFFF";
                  } else if (stackOpacity >= 0.75) {
                    hexColor = "#FFFFFFBF";
                  } else if (stackOpacity >= 0.5) {
                    hexColor = "#FFFFFF80";
                  } else if (stackOpacity >= 0.25) {
                    hexColor = "#FFFFFF40";
                  }
                  card.style.backgroundColor = hexColor;
                  card.style.opacity = stackOpacity.toString();

                } 

                return animate(
                  wrapper,
                  {
                    y: stackOffset,
                    scale: stackScale,
                  },
                  {
                    duration: 0.3,
                    easing: "ease-out",
                  }
                );
              })
            );
          }

          // Pause between notifications
          await new Promise((resolve) => setTimeout(resolve, 800));
        }

        // Hold final position for viewing
        await new Promise((resolve) => setTimeout(resolve, 2000));

        // Fade out all cards (bottom to top)
        await animate(
          wrappers,
          {
            opacity: 0,
            y: -50,
            scale: 0.8,
          },
          {
            duration: 0.4,
            delay: stagger(0.1, { from: "first" }), // Start from bottom (first in array)
            easing: "ease-in",
          }
        );

        return true;
      } catch (error) {
        console.error("Animation error:", error);
        return false;
      }
    }

    // Continuous looping animation
    let isAnimating = false;
    let shouldContinue = true;

    async function startContinuousLoop() {
      while (shouldContinue && document.contains(container)) {
        if (!isAnimating) {
          isAnimating = true;

          const success = await playNotificationSequence();

          if (success && shouldContinue) {
            // Short pause between cycles
            await new Promise((resolve) => setTimeout(resolve, 1000));
          }

          isAnimating = false;
        } else {
          // Wait a bit if animation is already running
          await new Promise((resolve) => setTimeout(resolve, 100));
        }
      }
    }

    function stopLoop() {
      shouldContinue = false;
    }

    // Intersection Observer to start/stop animation based on visibility
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting && !isAnimating) {
            shouldContinue = true;
            startContinuousLoop();
          } else if (!entry.isIntersecting) {
            stopLoop();
          }
        });
      },
      { threshold: 0.3 }
    );

    observer.observe(container);

    // Cleanup function
    return () => {
      observer.disconnect();
      stopLoop();
    };
  }

  // Initialize when DOM is ready
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initNotificationAnimation);
  } else {
    initNotificationAnimation();
  }
</script>
