---
interface Props {
  id?: string;
}

const { id = "funnel-container" } = Astro.props;
---

<div
  id={id}
  class="absolute inset-0 w-full h-full"
  data-funnel-id={id}
  style="contain: layout style paint; content-visibility: auto;"
></div>

<script>

  // ============================================================================
  // CONSTANTS
  // ============================================================================

  const MOBILE_BREAKPOINT = 768;
  const Y_OFFSET = -1.5;
  const MIN_SCALE = 0.2;
  const MIN_OPACITY = 0.01;
  const CURVATURE_FACTOR = 2.0;
  const SEEDED_RANDOM_MULTIPLIER = 10000;

  const DESKTOP_CONFIG = {
    initial: { x: 8, y: 8.5 },
    objectsPerTexture: 3,
    numLanes: { y: 4, x: 5 },
    xLaneVariance: 1.0,
    xLaneIndexMultiplier: 2,
    yLaneVariationFactor: 1,
    xLaneVariationFactor: 0.4,
    yLaneEdgeConcentration: 0.5,
    opacityFadeStart: 3,
    loopDurationMs: 80000,
    seeds: {
      primary: 6234,
      secondary: 7636,
      repetition: 1234,
    },
  };

  const MOBILE_CONFIG = {
    yDistance: 2.1,
    yOffset: 0,
    xVariance: 2,
    xOffset: -0.3,
    textureCount: 25,
    numLanes: { y: 5, x: 3 },
    yLaneVariationFactor: 0.6,
    xLaneVariationFactor: 0.6,
    yStartRangeMultiplier: 1.5,
    opacityFadeStart: 0.5,
    minOpacity: 0.1,
    scaleMin: 0.4,
    fadeEaseExponent: 1.5,
    loopDurationMs: 20000,
    seeds: {
      primary: 345,
      secondary: 678,
    },
    height: {
      availablePercent: 0.4,
      maxPx: 500,
      toUnitsDivisor: 100,
    },
  } as const;

  const VIEWPORT_CONFIG = {
    base: { width: 1440, height: 900 },
    distance: {
      baseX: 10,
      baseY: 8,
      minX: 6,
      maxX: 12,
      minY: 2,
      maxY: 10,
    },
  } as const;

  const textureDefinitions = [
    { path: "/assets/medias/index/hero/image-01.webp", width: 1.0 },
    { path: "/assets/medias/index/hero/image-02.webp", width: 0.8 },
    { path: "/assets/medias/index/hero/image-03.webp", width: 1.2 },
    { path: "/assets/medias/index/hero/image-04.webp", width: 0.9 },
    { path: "/assets/medias/index/hero/image-05.webp", width: 1.1 },
    { path: "/assets/medias/index/hero/image-06.webp", width: 0.7 },
    { path: "/assets/medias/index/hero/image-07.webp", width: 1.3 },
    { path: "/assets/medias/index/hero/image-08.webp", width: 0.8 },
    { path: "/assets/medias/index/hero/image-09.webp", width: 1.0 },
    { path: "/assets/medias/index/hero/image-10.webp", width: 0.9 },
    { path: "/assets/medias/index/hero/image-11.webp", width: 1.1 },
    { path: "/assets/medias/index/hero/image-12.webp", width: 0.6 },
    { path: "/assets/medias/index/hero/image-13.webp", width: 1.2 },
    { path: "/assets/medias/index/hero/image-14.webp", width: 0.8 },
    { path: "/assets/medias/index/hero/image-15.webp", width: 1.0 },
    { path: "/assets/medias/index/hero/image-16.webp", width: 0.9 },
    { path: "/assets/medias/index/hero/image-17.webp", width: 1.1 },
  ];

  // ============================================================================
  // HELPER FUNCTIONS
  // ============================================================================

  let X_DISTANCE = DESKTOP_CONFIG.initial.x;
  let Y_DISTANCE = DESKTOP_CONFIG.initial.y;
  let isMobile = window.innerWidth <= MOBILE_BREAKPOINT;

  // Seeded random for deterministic positioning
  function seededRandom(seed: number): number {
    const x = Math.sin(seed) * SEEDED_RANDOM_MULTIPLIER;
    return x - Math.floor(x);
  }

  // Calculate distances based on viewport
  function calculateDistances(width: number, height: number) {
    const widthScale = width / VIEWPORT_CONFIG.base.width;
    const heightScale = height / VIEWPORT_CONFIG.base.height;

    const xDistance = Math.max(
      VIEWPORT_CONFIG.distance.minX,
      Math.min(VIEWPORT_CONFIG.distance.maxX, VIEWPORT_CONFIG.distance.baseX * Math.sqrt(widthScale))
    );

    const yDistance = Math.max(
      VIEWPORT_CONFIG.distance.minY,
      Math.min(VIEWPORT_CONFIG.distance.maxY, VIEWPORT_CONFIG.distance.baseY * Math.sqrt(heightScale))
    );

    return { xDistance, yDistance };
  }

  // Get adjusted mobile Y distance
  function getAdjustedMobileYDistance(): number {
    const viewportHeight = window.innerHeight;
    const availableHeight = Math.min(
      viewportHeight * MOBILE_CONFIG.height.availablePercent,
      MOBILE_CONFIG.height.maxPx
    );
    return Math.min(
      MOBILE_CONFIG.yDistance,
      availableHeight / MOBILE_CONFIG.height.toUnitsDivisor
    );
  }

  // Y lane distribution for desktop
  function getDesktopYLaneDistribution(
    index: number,
    repetitionIndex: number,
    numLanes: number
  ): number {
    const seed = index * DESKTOP_CONFIG.seeds.primary + repetitionIndex * DESKTOP_CONFIG.seeds.repetition;
    const random = seededRandom(seed);

    // Simplified edge concentration: push values toward 0 or 1
    const concentration = DESKTOP_CONFIG.yLaneEdgeConcentration;
    const distanceFromCenter = Math.abs(random - 0.5) * 2;
    const edgePull = Math.pow(distanceFromCenter, 1 / (1 + concentration * 3));
    const weightedPosition = random < 0.5
      ? 0.5 - edgePull * 0.5
      : 0.5 + edgePull * 0.5;

    const laneIndex = Math.max(0, Math.min(numLanes - 1, Math.floor(weightedPosition * numLanes)));
    const laneHeight = (Y_DISTANCE * 2) / numLanes;
    const laneCenter = -Y_DISTANCE + (laneIndex + 0.5) * laneHeight;

    const variationSeed = seed + 10000;
    const laneVariation =
      (seededRandom(variationSeed) - 0.5) *
      laneHeight *
      DESKTOP_CONFIG.yLaneVariationFactor;

    return laneCenter + laneVariation;
  }

  // X lane distribution for desktop
  function getDesktopXLaneDistribution(
    index: number,
    repetitionIndex: number,
    baseX: number,
    numLanes: number
  ): number {
    const laneIndex =
      (index * DESKTOP_CONFIG.xLaneIndexMultiplier + repetitionIndex) %
      numLanes;

    const laneWidth = (DESKTOP_CONFIG.xLaneVariance * 2) / numLanes;
    const laneOffset =
      -DESKTOP_CONFIG.xLaneVariance + (laneIndex + 0.5) * laneWidth;

    const seed = index * DESKTOP_CONFIG.seeds.secondary + repetitionIndex * DESKTOP_CONFIG.seeds.repetition;
    const laneVariation =
      (seededRandom(seed) - 0.5) *
      laneWidth *
      DESKTOP_CONFIG.xLaneVariationFactor;

    return baseX + laneOffset + laneVariation;
  }

  // Y lane distribution for mobile
  function getMobileYLaneDistribution(
    index: number,
    totalObjects: number,
    numLanes: number,
    adjustedYDistance: number
  ): number {
    const laneIndex = Math.floor((index * numLanes) / totalObjects);

    const startRange = adjustedYDistance * MOBILE_CONFIG.yStartRangeMultiplier;
    const laneHeight = startRange / numLanes;
    const laneCenter = -adjustedYDistance - (laneIndex + 0.5) * laneHeight;

    const seed = index * MOBILE_CONFIG.seeds.primary;
    const laneVariation =
      (seededRandom(seed) - 0.5) *
      laneHeight *
      MOBILE_CONFIG.yLaneVariationFactor;

    return laneCenter + laneVariation;
  }

  // ============================================================================
  // ANIMATION CALCULATIONS
  // ============================================================================

  // Calculate X position (desktop)
  function calculateXPosition(
    direction: "left-to-right" | "right-to-left",
    progress: number
  ): number {
    const startX = direction === "left-to-right" ? -X_DISTANCE : X_DISTANCE;
    return startX + progress * (0 - startX);
  }

  // Calculate Y position with convergence (desktop)
  function calculateYPosition(
    direction: "left-to-right" | "right-to-left",
    x: number,
    startY: number,
    noiseOffset: number
  ): number {
    const startX = direction === "left-to-right" ? -X_DISTANCE : X_DISTANCE;
    const normalizedX = (x - startX) / (0 - startX);

    // Parabolic curve for convergence
    const curveY = startY * Math.pow(1 - normalizedX, CURVATURE_FACTOR);

    return curveY + noiseOffset;
  }

  // Calculate scale (desktop)
  function calculateScale(
    direction: "left-to-right" | "right-to-left",
    x: number
  ): number {
    const startX = direction === "left-to-right" ? -X_DISTANCE : X_DISTANCE;
    return 1 + ((x - startX) / (0 - startX)) * (MIN_SCALE - 1);
  }

  // Calculate mobile Y position
  function calculateMobileYPosition(progress: number, startY: number, adjustedYDistance: number): number {
    return startY + progress * (adjustedYDistance - startY);
  }

  // Calculate mobile scale
  function calculateMobileScale(y: number, adjustedYDistance: number): number {
    const normalizedY = Math.max(0, Math.min(1, (y - (-adjustedYDistance)) / (adjustedYDistance - (-adjustedYDistance))));
    const easedProgress = 1 - Math.pow(1 - normalizedY, 2);
    return 1 + easedProgress * (MOBILE_CONFIG.scaleMin - 1);
  }

  // ============================================================================
  // MAIN FUNNEL CLASS
  // ============================================================================

  interface FunnelObject {
    element: HTMLImageElement;
    startPosition: { x: number; y: number };
    offset: number;
    direction: "left-to-right" | "right-to-left" | "bottom-to-top";
    width: number;
  }

  class SimpleFunnel {
    private container: HTMLElement;
    private objects: FunnelObject[] = [];
    private animationFrameId: number | null = null;
    private isAnimating = false;
    private startTime = Date.now();
    private pausedTime = 0;
    private mode: "desktop" | "mobile";

    // Camera configuration matching Three.js version
    private readonly CAMERA_FOV = 50; // degrees
    private readonly CAMERA_Z = 8; // camera position
    private readonly CAMERA_FOV_RAD = (50 * Math.PI) / 180; // Pre-calculated

    // Dynamic conversion factor calculated from camera projection
    private unitToPx = 50;

    // Cache for per-frame calculations (mobile optimization)
    private cachedAdjustedYDistance = 0;

    constructor(containerId: string) {
      const container = document.getElementById(containerId);
      if (!container) throw new Error(`Container ${containerId} not found`);

      this.container = container;
      this.mode = isMobile ? "mobile" : "desktop";

      this.init();
    }

    private calculateUnitToPx() {
      // Calculate the conversion factor based on camera FOV and viewport
      // This replicates Three.js perspective projection
      const visibleHeight = 2 * this.CAMERA_Z * Math.tan(this.CAMERA_FOV_RAD / 2);
      this.unitToPx = this.container.clientHeight / visibleHeight;
    }

    private async init() {
      // Calculate unit to pixel conversion
      this.calculateUnitToPx();

      // Calculate initial distances
      const { xDistance, yDistance } = calculateDistances(
        window.innerWidth,
        window.innerHeight
      );
      X_DISTANCE = xDistance;
      Y_DISTANCE = yDistance;

      await this.loadImages();
      this.createObjects();
      this.setupObservers();
      this.resume();
    }

    private async loadImages(): Promise<void> {
      const dataToUse =
        this.mode === "mobile"
          ? textureDefinitions.slice(0, MOBILE_CONFIG.textureCount)
          : textureDefinitions;

      const promises = dataToUse.map((def) => {
        return new Promise<HTMLImageElement>((resolve, reject) => {
          const img = new Image();
          img.onload = () => resolve(img);
          img.onerror = reject;
          img.src = def.path;
        });
      });

      await Promise.all(promises);
    }

    private createObjects() {
      // Clear existing objects
      this.objects.forEach((obj) => obj.element.remove());
      this.objects = [];

      const dataToUse =
        this.mode === "mobile"
          ? textureDefinitions.slice(0, MOBILE_CONFIG.textureCount)
          : textureDefinitions;

      // Use DocumentFragment for batch DOM insertion (performance optimization)
      const fragment = document.createDocumentFragment();

      for (let i = 0; i < dataToUse.length; i++) {
        const textureDef = dataToUse[i];

        if (this.mode === "desktop") {
          for (
            let repetition = 0;
            repetition < DESKTOP_CONFIG.objectsPerTexture;
            repetition++
          ) {
            this.createDesktopObject(
              textureDef,
              i,
              dataToUse.length,
              "left-to-right",
              repetition,
              fragment
            );
            this.createDesktopObject(
              textureDef,
              i,
              dataToUse.length,
              "right-to-left",
              repetition,
              fragment
            );
          }
        } else {
          this.createMobileObject(textureDef, i, dataToUse.length, fragment);
        }
      }

      // Single DOM append for all objects
      this.container.appendChild(fragment);
    }

    private createDesktopObject(
      textureDef: { path: string; width: number },
      index: number,
      totalObjects: number,
      direction: "left-to-right" | "right-to-left",
      repetitionIndex: number,
      fragment: DocumentFragment
    ) {
      const img = document.createElement("img");
      img.src = textureDef.path;

      img.loading = "eager";
      img.decoding = "async";
      img.fetchPriority = "high";
      img.style.position = "absolute";
      img.style.pointerEvents = "none";
      img.style.willChange = "transform, opacity";
      img.style.backfaceVisibility = "hidden";

      // Center the transform origin to match Three.js mesh behavior
      img.style.transformOrigin = "center center";

      // Set image dimensions based on texture width
      const widthPx = textureDef.width * this.unitToPx;
      img.style.width = `${widthPx}px`;
      img.style.height = "auto";

      const baseX = direction === "left-to-right" ? -X_DISTANCE : X_DISTANCE;
      const x = getDesktopXLaneDistribution(
        index,
        repetitionIndex,
        baseX,
        DESKTOP_CONFIG.numLanes.x
      );
      const y = getDesktopYLaneDistribution(
        index,
        repetitionIndex,
        DESKTOP_CONFIG.numLanes.y
      );

      // Add z-index for depth layering (like Three.js z-position)
      const adjustedIndex = index + repetitionIndex * totalObjects;
      const zOffset = direction === "left-to-right" ? 0 : 100;
      img.style.zIndex = String(adjustedIndex + zOffset);
      const seedMultiplier =
        direction === "left-to-right"
          ? DESKTOP_CONFIG.seeds.primary
          : DESKTOP_CONFIG.seeds.secondary;
      const offsetSeed =
        adjustedIndex * seedMultiplier +
        repetitionIndex * DESKTOP_CONFIG.seeds.repetition;

      fragment.appendChild(img);

      this.objects.push({
        element: img,
        startPosition: { x, y: y + Y_OFFSET },
        offset: seededRandom(offsetSeed),
        direction,
        width: textureDef.width,
      });
    }

    private createMobileObject(
      textureDef: { path: string; width: number },
      index: number,
      totalObjects: number,
      fragment: DocumentFragment
    ) {
      const img = document.createElement("img");
      img.src = textureDef.path;

      // Only eager load first 5 images (preloaded above-the-fold)
      const isInitiallyVisible = index < 5;
      img.loading = isInitiallyVisible ? "eager" : "lazy";
      img.decoding = "async";
      img.fetchPriority = isInitiallyVisible ? "high" : "low";
      img.style.position = "absolute";
      img.style.pointerEvents = "none";
      img.style.willChange = "transform, opacity";
      img.style.backfaceVisibility = "hidden";

      // Center the transform origin to match Three.js mesh behavior
      img.style.transformOrigin = "center center";

      // Set image dimensions
      const widthPx = textureDef.width * this.unitToPx;
      img.style.width = `${widthPx}px`;
      img.style.height = "auto";

      // Add z-index for depth layering
      img.style.zIndex = String(index);

      const laneIndex = index % MOBILE_CONFIG.numLanes.x;
      const laneWidth = (MOBILE_CONFIG.xVariance * 2) / MOBILE_CONFIG.numLanes.x;
      const laneCenter =
        -MOBILE_CONFIG.xVariance + (laneIndex + 0.5) * laneWidth;
      const xVariation =
        (seededRandom(index * MOBILE_CONFIG.seeds.secondary) - 0.5) *
        laneWidth *
        MOBILE_CONFIG.xLaneVariationFactor;
      const x = laneCenter + xVariation;

      const adjustedYDistance = getAdjustedMobileYDistance();
      const y = getMobileYLaneDistribution(
        index,
        totalObjects,
        MOBILE_CONFIG.numLanes.y,
        adjustedYDistance
      );

      fragment.appendChild(img);

      this.objects.push({
        element: img,
        startPosition: { x, y: y + MOBILE_CONFIG.yOffset },
        offset: seededRandom(index * MOBILE_CONFIG.seeds.primary),
        direction: "bottom-to-top",
        width: textureDef.width,
      });
    }

    private updateImageSizes() {
      // Update all image sizes based on new unitToPx
      for (const object of this.objects) {
        const widthPx = object.width * this.unitToPx;
        object.element.style.width = `${widthPx}px`;
      }
    }

    private updateObject(object: FunnelObject, index: number, progress: number) {
      const uniqueProgress = (progress + object.offset) % 1;

      if (object.direction === "bottom-to-top") {
        this.updateMobileObject(object, index, uniqueProgress);
      } else {
        this.updateDesktopObject(object, index, uniqueProgress);
      }
    }

    private updateDesktopObject(
      object: FunnelObject,
      index: number,
      progress: number
    ) {
      const x = calculateXPosition(object.direction as "left-to-right" | "right-to-left", progress);

      // Skip calculations for invisible objects (performance optimization)
      const absX = Math.abs(x);
      const opacityRaw = 1 + ((absX - DESKTOP_CONFIG.opacityFadeStart) / (0 - DESKTOP_CONFIG.opacityFadeStart)) * (MIN_OPACITY - 1);
      const opacity = Math.max(MIN_OPACITY, Math.min(1, opacityRaw));

      if (opacity <= MIN_OPACITY) {
        object.element.style.opacity = "0";
        return;
      }

      const y = calculateYPosition(
        object.direction as "left-to-right" | "right-to-left",
        x,
        object.startPosition.y,
        0
      );

      const scale = calculateScale(object.direction as "left-to-right" | "right-to-left", x);

      // Convert from Three.js coordinate system to CSS
      const xPx = this.convertXToPixels(x);
      const yPx = this.convertYToPixels(y + Y_OFFSET);

      // Apply translate(-50%, -50%) to center the image at the coordinate (like Three.js meshes)
      object.element.style.transform = `translate3d(${xPx}px, ${yPx}px, 0) translate(-50%, -50%) scale(${scale})`;
      object.element.style.opacity = opacity.toString();
    }

    private updateMobileObject(
      object: FunnelObject,
      index: number,
      progress: number
    ) {
      // Use cached value instead of recalculating (3x performance boost)
      const adjustedYDistance = this.cachedAdjustedYDistance;

      const y = calculateMobileYPosition(progress, object.startPosition.y, adjustedYDistance);

      const x = object.startPosition.x + ((y - object.startPosition.y) / (adjustedYDistance - object.startPosition.y)) * (0 - object.startPosition.x);

      const scale = calculateMobileScale(y, adjustedYDistance);

      const normalizedY = Math.max(0, Math.min(1, Math.abs(y) / adjustedYDistance));
      const fadeStart = MOBILE_CONFIG.opacityFadeStart;

      let opacity: number;
      if (normalizedY < fadeStart) {
        opacity = 1;
      } else {
        const fadeProgress = (normalizedY - fadeStart) / (1 - fadeStart);
        opacity = Math.max(
          1 - Math.pow(fadeProgress, MOBILE_CONFIG.fadeEaseExponent),
          MOBILE_CONFIG.minOpacity
        );
      }

      // Convert from Three.js coordinate system to CSS
      const xPx = this.convertXToPixels(x + MOBILE_CONFIG.xOffset);
      const yPx = this.convertYToPixels(y + MOBILE_CONFIG.yOffset);

      // Apply translate(-50%, -50%) to center the image at the coordinate (like Three.js meshes)
      object.element.style.transform = `translate3d(${xPx}px, ${yPx}px, 0) translate(-50%, -50%) scale(${scale})`;
      object.element.style.opacity = opacity.toString();
    }

    // Convert Three.js coordinates to pixel coordinates
    private convertXToPixels(x: number): number {
      const centerX = this.container.clientWidth / 2;
      return centerX + x * this.unitToPx;
    }

    private convertYToPixels(y: number): number {
      const centerY = this.container.clientHeight / 2;
      return centerY - y * this.unitToPx; // Invert Y axis
    }

    private animate = () => {
      if (!this.isAnimating) return;

      const currentTime = Date.now();
      const elapsed = currentTime - this.startTime - this.pausedTime;
      const loopDuration =
        this.mode === "mobile"
          ? MOBILE_CONFIG.loopDurationMs
          : DESKTOP_CONFIG.loopDurationMs;
      const progress = (elapsed / loopDuration) % 1;

      // Cache adjusted Y distance once per frame (mobile optimization)
      if (this.mode === "mobile") {
        this.cachedAdjustedYDistance = getAdjustedMobileYDistance();
      }

      this.objects.forEach((object, index) => {
        this.updateObject(object, index, progress);
      });

      this.animationFrameId = requestAnimationFrame(this.animate);
    };

    private pause() {
      if (this.isAnimating && this.animationFrameId !== null) {
        this.isAnimating = false;
        cancelAnimationFrame(this.animationFrameId);
        this.animationFrameId = null;
        this.pausedTime = Date.now() - this.startTime - this.pausedTime;
      }
    }

    private resume() {
      if (!this.isAnimating) {
        this.isAnimating = true;
        this.startTime = Date.now() - this.pausedTime;
        this.animate();
      }
    }

    private setupObservers() {
      // Intersection observer for pause/resume
      const intersectionObserver = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              this.resume();
            } else {
              this.pause();
            }
          });
        },
        { threshold: 0.1 }
      );

      intersectionObserver.observe(this.container);

      // Visibility change listener
      const handleVisibilityChange = () => {
        if (document.hidden) {
          this.pause();
        } else {
          const rect = this.container.getBoundingClientRect();
          const isInViewport =
            rect.top < window.innerHeight && rect.bottom > 0;
          if (isInViewport) {
            this.resume();
          }
        }
      };

      document.addEventListener("visibilitychange", handleVisibilityChange);

      // Resize handler with debounce
      let resizeTimeout: number | null = null;
      const handleResize = () => {
        if (resizeTimeout !== null) clearTimeout(resizeTimeout);
        resizeTimeout = window.setTimeout(() => {
          const previousUnitToPx = this.unitToPx;

          // Recalculate unit to pixel conversion
          this.calculateUnitToPx();

          const newIsMobile = window.innerWidth <= MOBILE_BREAKPOINT;
          const modeChanged = newIsMobile !== isMobile;

          if (modeChanged) {
            isMobile = newIsMobile;
            this.mode = isMobile ? "mobile" : "desktop";
            this.createObjects();
          } else {
            // Update image sizes if unitToPx changed significantly
            const unitToPxChangeRatio = Math.abs(this.unitToPx - previousUnitToPx) / previousUnitToPx;
            if (unitToPxChangeRatio > 0.1) {
              this.updateImageSizes();
            }
          }

          // Recalculate distances
          const { xDistance, yDistance } = calculateDistances(
            window.innerWidth,
            window.innerHeight
          );
          X_DISTANCE = xDistance;
          Y_DISTANCE = yDistance;
        }, 150);
      };

      window.addEventListener("resize", handleResize);
    }
  }

  // ============================================================================
  // INITIALIZATION
  // ============================================================================

  function initAllFunnels() {
    const containers = document.querySelectorAll("[data-funnel-id]");
    containers.forEach((container) => {
      const isVisible = (container as HTMLElement).offsetParent !== null;
      if (isVisible) {
        const containerId = container.getAttribute("data-funnel-id");
        if (containerId) {
          new SimpleFunnel(containerId);
        }
      }
    });
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initAllFunnels);
  } else {
    initAllFunnels();
  }
</script>
