---

---

<canvas
  id="three-funnel-canvas"
  class="absolute inset-0 w-full h-full block"
  style="width: 100%; height: 100%; display: block;"></canvas>

<script>
  // @ts-nocheck
  import * as THREE from "three";
  import { createNoise2D } from "simplex-noise";

  const noise = createNoise2D();

  const X_DISTANCE = 8;
  const Y_DISTANCE = 4;

  // Mobile constants
  const MOBILE_BREAKPOINT = 768;
  const MOBILE_Y_DISTANCE = 1;
  const MOBILE_X_VARIANCE = 2;
  const MOBILE_TEXTURE_COUNT = 8;

  // Device detection
  let isMobile = window.innerWidth <= MOBILE_BREAKPOINT;

  // Texture data with custom width (height calculated from aspect ratio)
  interface TextureData {
    path: string;
    width: number;
  }

  const textureDefinitions: TextureData[] = [
    { path: "/assets/medias/index/hero/image-01.png", width: 1.0 },
    { path: "/assets/medias/index/hero/image-02.png", width: 0.8 },
    { path: "/assets/medias/index/hero/image-03.png", width: 1.2 },
    { path: "/assets/medias/index/hero/image-04.png", width: 0.9 },
    { path: "/assets/medias/index/hero/image-05.png", width: 1.1 },
    { path: "/assets/medias/index/hero/image-06.png", width: 0.7 },
    { path: "/assets/medias/index/hero/image-07.png", width: 1.3 },
    { path: "/assets/medias/index/hero/image-08.png", width: 0.8 },
    { path: "/assets/medias/index/hero/image-09.png", width: 1.0 },
    { path: "/assets/medias/index/hero/image-10.png", width: 0.9 },
    { path: "/assets/medias/index/hero/image-11.png", width: 1.1 },
    { path: "/assets/medias/index/hero/image-12.png", width: 0.6 },
    { path: "/assets/medias/index/hero/image-13.png", width: 1.2 },
    { path: "/assets/medias/index/hero/image-14.png", width: 0.8 },
    { path: "/assets/medias/index/hero/image-15.png", width: 1.0 },
    { path: "/assets/medias/index/hero/image-16.png", width: 0.9 },
    { path: "/assets/medias/index/hero/image-17.png", width: 1.1 },
  ];

  // Seeded random function for deterministic positioning
  function seededRandom(seed: number): number {
    const x = Math.sin(seed) * 10000;
    return x - Math.floor(x);
  }

  // Create base material for objects
  function createBaseMaterial(texture: THREE.Texture): THREE.MeshBasicMaterial {
    return new THREE.MeshBasicMaterial({
      map: texture,
      side: THREE.DoubleSide,
      transparent: true,
      opacity: 1,
      color: new THREE.Color(0xffffff),
    });
  }

  // Create funnel object (desktop mode)
  function createFunnelObject(
    texture: THREE.Texture,
    geometry: THREE.PlaneGeometry,
    direction: "left-to-right" | "right-to-left",
    index: number,
    scene: THREE.Scene
  ): {
    mesh: THREE.Mesh;
    startPosition: { x: number; y: number; z: number };
    offset: number;
    direction: "left-to-right" | "right-to-left";
  } {
    const material = createBaseMaterial(texture);
    const mesh = new THREE.Mesh(geometry, material);

    const x = direction === "left-to-right" ? -X_DISTANCE : X_DISTANCE;
    const y = THREE.MathUtils.mapLinear(
      seededRandom(index * (direction === "left-to-right" ? 123 : 789)),
      0,
      1,
      -Y_DISTANCE,
      Y_DISTANCE
    );
    const z =
      direction === "left-to-right" ? 0.0001 * index : 0.0001 * (index + 100);

    mesh.position.set(x, y, z);
    scene.add(mesh);

    return {
      mesh,
      startPosition: { x, y, z },
      offset: seededRandom(index * (direction === "left-to-right" ? 456 : 987)),
      direction,
    };
  }

  // Create mobile funnel object (bottom-to-top)
  function createMobileFunnelObject(
    texture: THREE.Texture,
    geometry: THREE.PlaneGeometry,
    index: number,
    scene: THREE.Scene
  ): {
    mesh: THREE.Mesh;
    startPosition: { x: number; y: number; z: number };
    offset: number;
    direction: "bottom-to-top";
  } {
    const material = createBaseMaterial(texture);
    const mesh = new THREE.Mesh(geometry, material);

    const x = THREE.MathUtils.mapLinear(
      seededRandom(index * 345),
      0,
      1,
      -MOBILE_X_VARIANCE,
      MOBILE_X_VARIANCE
    );
    const y = -MOBILE_Y_DISTANCE;
    const z = 0.0001 * index;

    mesh.position.set(x, y, z);
    scene.add(mesh);

    return {
      mesh,
      startPosition: { x, y, z },
      offset: seededRandom(index * 678),
      direction: "bottom-to-top",
    };
  }

  // Calculate X position based on direction and progress
  function calculateXPosition(
    direction: "left-to-right" | "right-to-left",
    progress: number
  ): number {
    if (direction === "left-to-right") {
      return THREE.MathUtils.mapLinear(progress, 0, 1, -X_DISTANCE, 0);
    } else {
      return THREE.MathUtils.mapLinear(progress, 0, 1, X_DISTANCE, 0);
    }
  }

  // Calculate Y position with convergence and noise
  function calculateYPosition(
    direction: "left-to-right" | "right-to-left",
    x: number,
    startY: number,
    noiseOffset: number
  ): number {
    const baseY =
      direction === "left-to-right"
        ? THREE.MathUtils.mapLinear(x, -X_DISTANCE, 0, startY, 0)
        : THREE.MathUtils.mapLinear(x, X_DISTANCE, 0, startY, 0);

    return baseY + noiseOffset;
  }

  // Calculate scale based on position (desktop)
  function calculateScale(
    direction: "left-to-right" | "right-to-left",
    x: number
  ): number {
    if (direction === "left-to-right") {
      return THREE.MathUtils.mapLinear(x, -X_DISTANCE, 0, 1, 0.2);
    } else {
      return THREE.MathUtils.mapLinear(x, X_DISTANCE, 0, 1, 0.2);
    }
  }

  // Mobile-specific calculation functions
  function calculateMobileYPosition(progress: number): number {
    return THREE.MathUtils.mapLinear(progress, 0, 1, -MOBILE_Y_DISTANCE, MOBILE_Y_DISTANCE);
  }

  function calculateMobileScale(y: number): number {
    return THREE.MathUtils.mapLinear(y, -MOBILE_Y_DISTANCE, MOBILE_Y_DISTANCE, 1, 0.3);
  }

  // Animate individual object (desktop)
  function updateObject(
    object: {
      mesh: THREE.Mesh;
      startPosition: { x: number; y: number; z: number };
      offset: number;
      direction: "left-to-right" | "right-to-left";
    },
    index: number,
    progress: number
  ): void {
    const { mesh, offset, direction, startPosition } = object;
    const uniqueProgress = (progress + offset) % 1;

    const x = calculateXPosition(direction, uniqueProgress);

    const noiseInput = uniqueProgress * Math.PI * 2;
    const yOffset =
      noise(Math.cos(noiseInput) + index, Math.sin(noiseInput)) * 0.0001;

    const y = calculateYPosition(direction, x, startPosition.y, yOffset);

    const scale = calculateScale(direction, x);
    const opacity = THREE.MathUtils.mapLinear(Math.abs(x), 1.5, 0, 1, 0.01);

    if (opacity < 1) {
      (mesh.material as THREE.MeshBasicMaterial).opacity = opacity;
    } else {
      (mesh.material as THREE.MeshBasicMaterial).opacity = 1;
    }
    (mesh.material as THREE.MeshBasicMaterial).needsUpdate = true;

    mesh.position.x = x;
    mesh.position.y = y;
    mesh.scale.set(scale, scale, 1);
  }

  // Animate individual object (mobile)
  function updateMobileObject(
    object: {
      mesh: THREE.Mesh;
      startPosition: { x: number; y: number; z: number };
      offset: number;
      direction: "bottom-to-top";
    },
    index: number,
    progress: number
  ): void {
    const { mesh, offset, startPosition } = object;
    const uniqueProgress = (progress + offset) % 1;

    const y = calculateMobileYPosition(uniqueProgress);

    const noiseInput = uniqueProgress * Math.PI * 2;
    const xOffset =
      noise(Math.cos(noiseInput) + index, Math.sin(noiseInput)) * 0.01;
    const x =  THREE.MathUtils.mapLinear(y, -MOBILE_Y_DISTANCE, MOBILE_Y_DISTANCE, startPosition.x, 0)+ xOffset

    const scale = calculateMobileScale(y);
    const opacity = THREE.MathUtils.mapLinear(Math.abs(y), MOBILE_Y_DISTANCE*0.5, MOBILE_Y_DISTANCE, 1, 0);

    (mesh.material as THREE.MeshBasicMaterial).opacity = Math.max(opacity, 0.1);
    (mesh.material as THREE.MeshBasicMaterial).needsUpdate = true;

    mesh.position.x = x;
    mesh.position.y = y;
    mesh.scale.set(scale, scale, 1);
  }

  function getCanvasDimensions(canvas: HTMLCanvasElement): {
    width: number;
    height: number;
  } {
    const rect = canvas.getBoundingClientRect();
    let width = rect.width || canvas.clientWidth;
    let height = rect.height || canvas.clientHeight;

    if (width <= 0 || height <= 0) {
      const parent = canvas.parentElement;
      if (parent) {
        const parentRect = parent.getBoundingClientRect();
        const paddingOffset = 32;
        width = Math.max(parentRect.width - paddingOffset, 1);
        height = Math.max(parentRect.height - paddingOffset, 1);
      }
    }

    return {
      width: width || 1,
      height: height || 1,
    };
  }

  // Main initialization function
  async function initThreeFunnel() {
    const canvas = document.getElementById(
      "three-funnel-canvas"
    ) as HTMLCanvasElement;
    if (!canvas) return;

    let retries = 0;
    const maxRetries = 10;
    let dimensions = getCanvasDimensions(canvas);

    while (
      (dimensions.width <= 1 || dimensions.height <= 1) &&
      retries < maxRetries
    ) {
      await new Promise((resolve) => setTimeout(resolve, 100));
      dimensions = getCanvasDimensions(canvas);
      retries++;
    }

    const { width, height } = dimensions;

    canvas.width = width;
    canvas.height = height;

    const renderer = new THREE.WebGLRenderer({
      canvas,
      antialias: !isMobile, // Disable antialiasing on mobile for performance
      alpha: true,
    });
    renderer.setSize(width, height);
    // Reduce pixel ratio on mobile for better performance
    renderer.setPixelRatio(isMobile ? Math.min(window.devicePixelRatio, 2) : window.devicePixelRatio);
    renderer.setClearColor(0x000000, 0);
    renderer.sortObjects = true;

    const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
    camera.position.set(0, 0, 8);
    camera.lookAt(0, 0, 0);

    const scene = new THREE.Scene();

    const textureLoader = new THREE.TextureLoader();
    const LOOP_DURATION = isMobile ? 25000 : 40000; // Faster animation on mobile

    interface LoadedTextureData {
      texture: THREE.Texture;
      width: number;
      height: number;
      index: number;
    }

    let objects: Array<{
      mesh: THREE.Mesh;
      startPosition: { x: number; y: number; z: number };
      offset: number;
      direction: "left-to-right" | "right-to-left" | "bottom-to-top";
    }> = [];

    const createGeometry = (
      width: number,
      height: number
    ): THREE.PlaneGeometry => {
      return new THREE.PlaneGeometry(width, height);
    };
    const loadTexturePromises = textureDefinitions.map(
      (textureDefinition, i) => {
        return new Promise<LoadedTextureData | null>((resolve) => {
          const texture = textureLoader.load(
            textureDefinition.path,
            () => {
              const aspectRatio = texture.image.width / texture.image.height;
              const height = textureDefinition.width / aspectRatio;

              resolve({
                texture,
                width: textureDefinition.width,
                height: height,
                index: i,
              });
            },
            undefined,
            (error: unknown) => {
              console.error(
                `Error loading texture ${i + 1}:`,
                textureDefinition.path,
                error
              );
              resolve(null);
            }
          );
        });
      }
    );

    const loadedTextureData = await Promise.all(loadTexturePromises);
    const validTextureData = loadedTextureData.filter(
      (data): data is NonNullable<typeof data> => data !== null
    );

    // Function to create objects based on current mode
    function createObjectsForMode(mode: 'desktop' | 'mobile') {
      // Clear existing objects
      objects.forEach(obj => scene.remove(obj.mesh));
      objects = [];

      const dataToUse = mode === 'mobile'
        ? validTextureData.slice(0, MOBILE_TEXTURE_COUNT)
        : validTextureData;

      for (const { texture, width, height, index: i } of dataToUse) {
        const geometry = createGeometry(width, height);

        if (mode === 'desktop') {
          const leftObject = createFunnelObject(
            texture,
            geometry,
            "left-to-right",
            i,
            scene
          );
          objects.push(leftObject);

          const rightObject = createFunnelObject(
            texture,
            geometry.clone(),
            "right-to-left",
            i,
            scene
          );
          objects.push(rightObject);
        } else {
          const mobileObject = createMobileFunnelObject(
            texture,
            geometry,
            i,
            scene
          );
          objects.push(mobileObject as any);
        }
      }
    }

    // Initialize objects for current mode
    createObjectsForMode(isMobile ? 'mobile' : 'desktop');

    let startTime = Date.now();

    function animate() {
      const currentTime = Date.now();
      const elapsed = currentTime - startTime;
      const progress = (elapsed / LOOP_DURATION) % 1;

      objects.forEach((object, index) => {
        if (isMobile) {
          updateMobileObject(object as any, index, progress);
        } else {
          updateObject(object as any, index, progress);
        }
      });

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    animate();

    let currentWidth = width;
    let currentHeight = height;

    function onWindowResize() {
      const clientWidth = window.innerWidth;
      const clientHeight = window.innerHeight;

      if (clientWidth === currentWidth && clientHeight === currentHeight) {
        return;
      }

      if (clientWidth <= 0 || clientHeight <= 0) {
        return;
      }

      // Check if mode changed
      const newIsMobile = clientWidth <= MOBILE_BREAKPOINT;
      if (newIsMobile !== isMobile) {
        isMobile = newIsMobile;
        createObjectsForMode(isMobile ? 'mobile' : 'desktop');
      }

      currentWidth = clientWidth;
      currentHeight = clientHeight;

      camera.aspect = clientWidth / clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(clientWidth, clientHeight);
      // Adjust pixel ratio based on mode
      renderer.setPixelRatio(isMobile ? Math.min(window.devicePixelRatio, 2) : window.devicePixelRatio);
    }


    if (typeof ResizeObserver !== "undefined") {
      const resizeObserver = new ResizeObserver(() => {
        onWindowResize();
      });
      resizeObserver.observe(canvas);
    }

    window.addEventListener("resize", onWindowResize);

    window.addEventListener("orientationchange", () => {
      setTimeout(onWindowResize, 100);
    });

    
    return () => {
      window.removeEventListener("resize", onWindowResize);
      window.removeEventListener("orientationchange", onWindowResize);
      renderer.dispose();
      scene.clear();
    };
  }

  // Initialize when page loads
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initThreeFunnel);
  } else {
    initThreeFunnel();
  }
</script>
