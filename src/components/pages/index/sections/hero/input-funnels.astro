---

---

<canvas
  id="three-funnel-canvas"
  class="absolute inset-0 w-full h-full block"
  style="width: 100%; height: 100%; display: block;"></canvas>

<script>
  // @ts-nocheck
  import * as THREE from "three";
  import { createNoise2D } from "simplex-noise";

  const noise = createNoise2D();

  const X_DISTANCE = 8;
  const Y_DISTANCE = 4;

  // Texture data with custom width (height calculated from aspect ratio)
  interface TextureData {
    path: string;
    width: number;
  }

  const textureDefinitions: TextureData[] = [
    { path: "/assets/medias/index/hero/image-01.png", width: 1.0 },
    { path: "/assets/medias/index/hero/image-02.png", width: 0.8 },
    { path: "/assets/medias/index/hero/image-03.png", width: 1.2 },
    { path: "/assets/medias/index/hero/image-04.png", width: 0.9 },
    { path: "/assets/medias/index/hero/image-05.png", width: 1.1 },
    { path: "/assets/medias/index/hero/image-06.png", width: 0.7 },
    { path: "/assets/medias/index/hero/image-07.png", width: 1.3 },
    { path: "/assets/medias/index/hero/image-08.png", width: 0.8 },
    { path: "/assets/medias/index/hero/image-09.png", width: 1.0 },
    { path: "/assets/medias/index/hero/image-10.png", width: 0.9 },
    { path: "/assets/medias/index/hero/image-11.png", width: 1.1 },
    { path: "/assets/medias/index/hero/image-12.png", width: 0.6 },
    { path: "/assets/medias/index/hero/image-13.png", width: 1.2 },
    { path: "/assets/medias/index/hero/image-14.png", width: 0.8 },
    { path: "/assets/medias/index/hero/image-15.png", width: 1.0 },
    { path: "/assets/medias/index/hero/image-16.png", width: 0.9 },
    { path: "/assets/medias/index/hero/image-17.png", width: 1.1 },
  ];

  // Seeded random function for deterministic positioning
  function seededRandom(seed: number): number {
    const x = Math.sin(seed) * 10000;
    return x - Math.floor(x);
  }

  // Create base material for objects
  function createBaseMaterial(texture: THREE.Texture): THREE.MeshBasicMaterial {
    return new THREE.MeshBasicMaterial({
      map: texture,
      side: THREE.DoubleSide,
      transparent: true,
      opacity: 1,
      color: new THREE.Color(0xffffff),
    });
  }

  // Create funnel object
  function createFunnelObject(
    texture: THREE.Texture,
    geometry: THREE.PlaneGeometry,
    direction: "left-to-right" | "right-to-left",
    index: number,
    scene: THREE.Scene
  ): {
    mesh: THREE.Mesh;
    startPosition: { x: number; y: number; z: number };
    offset: number;
    direction: "left-to-right" | "right-to-left";
  } {
    const material = createBaseMaterial(texture);
    const mesh = new THREE.Mesh(geometry, material);

    // Configure positions based on direction
    const x = direction === "left-to-right" ? -X_DISTANCE : X_DISTANCE;
    const y = THREE.MathUtils.mapLinear(
      seededRandom(index * (direction === "left-to-right" ? 123 : 789)),
      0,
      1,
      -Y_DISTANCE,
      Y_DISTANCE
    );
    const z =
      direction === "left-to-right" ? 0.0001 * index : 0.0001 * (index + 100);

    mesh.position.set(x, y, z);
    scene.add(mesh);

    return {
      mesh,
      startPosition: { x, y, z },
      offset: seededRandom(index * (direction === "left-to-right" ? 456 : 987)),
      direction,
    };
  }

  // Calculate X position based on direction and progress
  function calculateXPosition(
    direction: "left-to-right" | "right-to-left",
    progress: number
  ): number {
    if (direction === "left-to-right") {
      return THREE.MathUtils.mapLinear(progress, 0, 1, -X_DISTANCE, 0);
    } else {
      return THREE.MathUtils.mapLinear(progress, 0, 1, X_DISTANCE, 0);
    }
  }

  // Calculate Y position with convergence and noise
  function calculateYPosition(
    direction: "left-to-right" | "right-to-left",
    x: number,
    startY: number,
    noiseOffset: number
  ): number {
    const baseY =
      direction === "left-to-right"
        ? THREE.MathUtils.mapLinear(x, -X_DISTANCE, 0, startY, 0)
        : THREE.MathUtils.mapLinear(x, X_DISTANCE, 0, startY, 0);

    return baseY + noiseOffset;
  }

  // Calculate scale based on position
  function calculateScale(
    direction: "left-to-right" | "right-to-left",
    x: number
  ): number {
    if (direction === "left-to-right") {
      return THREE.MathUtils.mapLinear(x, -X_DISTANCE, 0, 1, 0.2);
    } else {
      return THREE.MathUtils.mapLinear(x, X_DISTANCE, 0, 1, 0.2);
    }
  }

  // Animate individual object
  function updateObject(
    object: {
      mesh: THREE.Mesh;
      startPosition: { x: number; y: number; z: number };
      offset: number;
      direction: "left-to-right" | "right-to-left";
    },
    index: number,
    progress: number
  ): void {
    const { mesh, offset, direction, startPosition } = object;
    const uniqueProgress = (progress + offset) % 1;

    // Calculate position X
    const x = calculateXPosition(direction, uniqueProgress);

    // Calculate periodic noise for Y variation
    const noiseInput = uniqueProgress * Math.PI * 2;
    const yOffset =
      noise(Math.cos(noiseInput) + index, Math.sin(noiseInput)) * 0.0001;

    // Calculate position Y with convergence
    const y = calculateYPosition(direction, x, startPosition.y, yOffset);

    // Calculate scale
    const scale = calculateScale(direction, x);
    const opacity = THREE.MathUtils.mapLinear(Math.abs(x), 1.5, 0, 1, 0.01);

    if (opacity < 1) {
      (mesh.material as THREE.MeshBasicMaterial).opacity = opacity;
    } else {
      (mesh.material as THREE.MeshBasicMaterial).opacity = 1;
    }
    (mesh.material as THREE.MeshBasicMaterial).needsUpdate = true;

    mesh.position.x = x;
    mesh.position.y = y;
    mesh.scale.set(scale, scale, 1);
  }

  // Force canvas to recalculate its size
  function forceCanvasResize(canvas: HTMLCanvasElement): void {
    // Force reflow by reading layout properties
    canvas.offsetHeight;
    canvas.offsetWidth;

    // Temporarily remove and re-add size styles to trigger recalculation
    const originalWidth = canvas.style.width;
    const originalHeight = canvas.style.height;

    canvas.style.width = "";
    canvas.style.height = "";

    // Force reflow
    canvas.offsetHeight;

    canvas.style.width = originalWidth || "100%";
    canvas.style.height = originalHeight || "100%";
  }

  function getCanvasDimensions(
    canvas: HTMLCanvasElement,
    forceResize: boolean = false
  ): {
    width: number;
    height: number;
  } {
    if (forceResize) {
      forceCanvasResize(canvas);
    }

    // Use the actual canvas element dimensions from its container
    const rect = canvas.getBoundingClientRect();
    let width = rect.width || canvas.clientWidth;
    let height = rect.height || canvas.clientHeight;

    console.log("🔍 Canvas dimensions check:", {
      "rect.width": rect.width,
      "rect.height": rect.height,
      "canvas.clientWidth": canvas.clientWidth,
      "canvas.clientHeight": canvas.clientHeight,
      "canvas.offsetWidth": canvas.offsetWidth,
      "canvas.offsetHeight": canvas.offsetHeight,
      "computed width": width,
      "computed height": height,
      forceResize: forceResize,
    });

    // Fallback to parent container dimensions if canvas is still 0
    if (width <= 0 || height <= 0) {
      const parent = canvas.parentElement;
      if (parent) {
        const parentRect = parent.getBoundingClientRect();
        // Account for padding in the parent (p-4 = 16px padding)
        const paddingOffset = 32; // 16px * 2 (left + right, top + bottom)
        width = Math.max(parentRect.width - paddingOffset, 1);
        height = Math.max(parentRect.height - paddingOffset, 1);

        console.log("📦 Parent container fallback:", {
          "parent.tagName": parent.tagName,
          "parent.className": parent.className,
          "parentRect.width": parentRect.width,
          "parentRect.height": parentRect.height,
          "adjusted width": width,
          "adjusted height": height,
          paddingOffset: paddingOffset,
        });
      }
    }

    return {
      width: width || 1,
      height: height || 1,
    };
  }

  // Main initialization function
  async function initThreeFunnel() {
    const canvas = document.getElementById(
      "three-funnel-canvas"
    ) as HTMLCanvasElement;
    if (!canvas) return;

    // Wait for canvas to have proper dimensions
    let retries = 0;
    const maxRetries = 10;
    let dimensions = getCanvasDimensions(canvas);

    while (
      (dimensions.width <= 1 || dimensions.height <= 1) &&
      retries < maxRetries
    ) {
      await new Promise((resolve) => setTimeout(resolve, 100));
      dimensions = getCanvasDimensions(canvas);
      retries++;
    }

    const { width, height } = dimensions;

    console.log("Canvas initialized with dimensions:", { width, height });

    // Set canvas element dimensions
    canvas.width = width;
    canvas.height = height;

    // Setup renderer
    const renderer = new THREE.WebGLRenderer({
      canvas,
      antialias: true,
      alpha: true,
    });
    renderer.setSize(width, height);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setClearColor(0x000000, 0); // Transparent background
    renderer.sortObjects = true;

    // Setup camera
    const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
    camera.position.set(0, 0, 8);
    camera.lookAt(0, 0, 0);

    // Setup scene
    const scene = new THREE.Scene();

    const textureLoader = new THREE.TextureLoader();
    const LOOP_DURATION = 20000; // 20 seconds

    interface LoadedTextureData {
      texture: THREE.Texture;
      width: number;
      height: number;
      index: number;
    }

    const objects: {
      mesh: THREE.Mesh;
      startPosition: { x: number; y: number; z: number };
      offset: number;
      direction: "left-to-right" | "right-to-left";
    }[] = [];

    // Create geometry with custom dimensions
    const createGeometry = (
      width: number,
      height: number
    ): THREE.PlaneGeometry => {
      return new THREE.PlaneGeometry(width, height);
    };

    // Load textures asynchronously and calculate height from aspect ratio
    const loadTexturePromises = textureDefinitions.map(
      (textureDefinition, i) => {
        return new Promise<LoadedTextureData | null>((resolve) => {
          const texture = textureLoader.load(
            textureDefinition.path,
            // onLoad
            () => {
              // Calculate height based on image aspect ratio to maintain proportions
              const aspectRatio = texture.image.width / texture.image.height;
              const height = textureDefinition.width / aspectRatio;

              resolve({
                texture,
                width: textureDefinition.width,
                height: height,
                index: i,
              });
            },
            // onProgress
            undefined,
            // onError
            (error: unknown) => {
              console.error(
                `Error loading texture ${i + 1}:`,
                textureDefinition.path,
                error
              );
              resolve(null);
            }
          );
        });
      }
    );

    const loadedTextureData = await Promise.all(loadTexturePromises);
    const validTextureData = loadedTextureData.filter(
      (data): data is NonNullable<typeof data> => data !== null
    );

    // Create objects with custom dimensions
    for (const { texture, width, height, index: i } of validTextureData) {
      const geometry = createGeometry(width, height);

      // Left to right object
      const leftObject = createFunnelObject(
        texture,
        geometry,
        "left-to-right",
        i,
        scene
      );
      objects.push(leftObject);

      // Right to left object
      const rightObject = createFunnelObject(
        texture,
        geometry.clone(),
        "right-to-left",
        i,
        scene
      );
      objects.push(rightObject);
    }

    // Animation loop
    let startTime = Date.now();

    function animate() {
      const currentTime = Date.now();
      const elapsed = currentTime - startTime;
      const progress = (elapsed / LOOP_DURATION) % 1;

      objects.forEach((object, index) => {
        updateObject(object, index, progress);
      });

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    animate();

    // Store current dimensions to detect actual changes
    let currentWidth = width;
    let currentHeight = height;

    // Handle resize with improved responsiveness
    function onWindowResize() {
      console.log("🚨 Resize event triggered!");
      try {
        const { width: newWidth, height: newHeight } = getCanvasDimensions(
          canvas,
          true
        );

        console.log("📏 Current vs New dimensions:", {
          current: { width: currentWidth, height: currentHeight },
          new: { width: newWidth, height: newHeight },
          difference: {
            width: Math.abs(newWidth - currentWidth),
            height: Math.abs(newHeight - currentHeight),
          },
        });

        // Only update if dimensions actually changed (with small tolerance for floating point)
        const tolerance = 1;
        if (
          Math.abs(newWidth - currentWidth) < tolerance &&
          Math.abs(newHeight - currentHeight) < tolerance
        ) {
          console.log(
            "⏭️ Skipping resize - dimensions unchanged (within tolerance)"
          );
          return;
        }

        // Validate dimensions
        if (newWidth <= 0 || newHeight <= 0) {
          console.warn("❌ Invalid canvas dimensions during resize:", {
            newWidth,
            newHeight,
          });
          return;
        }

        console.log("✅ Applying resize:", {
          from: { width: currentWidth, height: currentHeight },
          to: { width: newWidth, height: newHeight },
        });

        // Update stored dimensions
        currentWidth = newWidth;
        currentHeight = newHeight;

        // Update canvas element dimensions
        canvas.width = newWidth;
        canvas.height = newHeight;
        console.log("🖼️ Canvas element dimensions updated:", {
          width: canvas.width,
          height: canvas.height,
        });

        // Update camera aspect ratio and projection matrix
        camera.aspect = newWidth / newHeight;
        camera.updateProjectionMatrix();

        console.log("📷 Camera updated:", {
          aspect: camera.aspect,
          newAspect: newWidth / newHeight,
        });

        // Update renderer size (false parameter prevents CSS style updates)
        renderer.setSize(newWidth, newHeight, false);
        console.log("🎨 Renderer size updated");

        // Update pixel ratio in case of device changes
        renderer.setPixelRatio(window.devicePixelRatio);
        console.log("🖥️ Pixel ratio updated to:", window.devicePixelRatio);

        // Force a render to immediately show changes
        renderer.render(scene, camera);
        console.log("🎬 Forced render complete");
      } catch (error) {
        console.error("💥 Error during resize:", error);
      }
    }

    // Use ResizeObserver for more accurate canvas size changes
    let resizeObserver: ResizeObserver | null = null;
    if (typeof ResizeObserver !== "undefined") {
      console.log("🔍 Setting up ResizeObserver");
      resizeObserver = new ResizeObserver((entries) => {
        console.log(
          "🎯 ResizeObserver triggered with entries:",
          entries.length
        );
        for (const entry of entries) {
          if (entry.target === canvas) {
            console.log("📐 ResizeObserver detected canvas resize:", {
              contentRect: entry.contentRect,
              borderBoxSize: entry.borderBoxSize,
              contentBoxSize: entry.contentBoxSize,
            });
            onWindowResize();
          }
        }
      });
      resizeObserver.observe(canvas);
      console.log("👀 ResizeObserver is now observing canvas");
    } else {
      console.log("❌ ResizeObserver not supported, using fallback");
    }

    // Fallback resize handlers for browsers that don't support ResizeObserver
    window.addEventListener("resize", () => {
      console.log("🌐 Window resize event triggered");
      onWindowResize();
    });
    window.addEventListener("orientationchange", () => {
      console.log("📱 Orientation change event triggered");
      // Small delay for orientation change to complete
      setTimeout(() => {
        console.log("📱 Orientation change timeout executed");
        onWindowResize();
      }, 100);
    });

    // Cleanup function
    return () => {
      if (resizeObserver) {
        resizeObserver.unobserve(canvas);
        resizeObserver.disconnect();
      }
      window.removeEventListener("resize", onWindowResize);
      window.removeEventListener("orientationchange", onWindowResize);
      renderer.dispose();
      scene.clear();
    };
  }

  // Initialize when page loads
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initThreeFunnel);
  } else {
    initThreeFunnel();
  }
</script>
