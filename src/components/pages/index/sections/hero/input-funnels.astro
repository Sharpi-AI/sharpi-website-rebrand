---

---

<canvas
  id="three-funnel-canvas"
  class="absolute inset-0 w-full h-full block"
  style="width: 100%; height: 100%; display: block;"></canvas>

<script>
  import * as THREE from "three";
  import { createNoise2D } from "simplex-noise";

  const noise = createNoise2D();

  const X_DISTANCE = 8;
  const Y_DISTANCE = 3;

  const MOBILE_BREAKPOINT = 768;
  const MOBILE_Y_DISTANCE = 1;
  const MOBILE_X_VARIANCE = 2;
  const MOBILE_TEXTURE_COUNT = 8;

  let isMobile = window.innerWidth <= MOBILE_BREAKPOINT;

  interface TextureData {
    path: string;
    width: number;
  }

  interface FunnelObject {
    mesh: THREE.Mesh;
    startPosition: { x: number; y: number; z: number };
    offset: number;
    direction: "left-to-right" | "right-to-left" | "bottom-to-top";
    cachedOpacity?: number;
  }

  const textureDefinitions: TextureData[] = [
    { path: "/assets/medias/index/hero/image-01.png", width: 1.0 },
    { path: "/assets/medias/index/hero/image-02.png", width: 0.8 },
    { path: "/assets/medias/index/hero/image-03.png", width: 1.2 },
    { path: "/assets/medias/index/hero/image-04.png", width: 0.9 },
    { path: "/assets/medias/index/hero/image-05.png", width: 1.1 },
    { path: "/assets/medias/index/hero/image-06.png", width: 0.7 },
    { path: "/assets/medias/index/hero/image-07.png", width: 1.3 },
    { path: "/assets/medias/index/hero/image-08.png", width: 0.8 },
    { path: "/assets/medias/index/hero/image-09.png", width: 1.0 },
    { path: "/assets/medias/index/hero/image-10.png", width: 0.9 },
    { path: "/assets/medias/index/hero/image-11.png", width: 1.1 },
    { path: "/assets/medias/index/hero/image-12.png", width: 0.6 },
    { path: "/assets/medias/index/hero/image-13.png", width: 1.2 },
    { path: "/assets/medias/index/hero/image-14.png", width: 0.8 },
    { path: "/assets/medias/index/hero/image-15.png", width: 1.0 },
    { path: "/assets/medias/index/hero/image-16.png", width: 0.9 },
    { path: "/assets/medias/index/hero/image-17.png", width: 1.1 },
  ];

  // Seeded random function for deterministic positioning
  function seededRandom(seed: number): number {
    const x = Math.sin(seed) * 10000;
    return x - Math.floor(x);
  }

  // Create base material for objects
  function createBaseMaterial(texture: THREE.Texture): THREE.MeshBasicMaterial {
    return new THREE.MeshBasicMaterial({
      map: texture,
      side: THREE.DoubleSide,
      transparent: true,
      opacity: 1,
      color: new THREE.Color(0xffffff),
    });
  }

  function getImprovedYDistribution(
    index: number,
    direction: "left-to-right" | "right-to-left",
    totalObjects: number,
    distributionType: "uniform" | "gaussian" | "layered" | "spiral" = "layered"
  ): number {
    const seed = index * (direction === "left-to-right" ? 123 : 789);
    const random = seededRandom(seed);

    switch (distributionType) {
      case "uniform":
        // Distribuição uniforme simples (original)
        return THREE.MathUtils.mapLinear(random, 0, 1, -Y_DISTANCE, Y_DISTANCE);

      case "gaussian":
        // Distribuição gaussiana (mais objetos no centro)
        const u1 = seededRandom(seed + 1000);
        const u2 = seededRandom(seed + 2000);
        const gaussian =
          Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
        return THREE.MathUtils.clamp(
          gaussian * (Y_DISTANCE * 0.5),
          -Y_DISTANCE,
          Y_DISTANCE
        );

      case "layered":
        // Distribuição em camadas para melhor cobertura
        const numLayers = Math.ceil(Math.sqrt(totalObjects / 2)); // Layers baseadas no número de objetos
        const layerHeight = (Y_DISTANCE * 2) / numLayers;
        const layerIndex = Math.floor(random * numLayers);
        const layerCenter = -Y_DISTANCE + (layerIndex + 0.5) * layerHeight;

        // Adicionar variação dentro da camada
        const layerVariation = seededRandom(seed + 3000) * layerHeight * 0.3;
        return layerCenter + layerVariation;

      case "spiral":
        // Distribuição em espiral para criar padrão mais orgânico
        const spiralTurns = 2; // Número de voltas da espiral
        const angle = (index / totalObjects) * spiralTurns * Math.PI * 2;
        const spiralRadius = (index / totalObjects) * Y_DISTANCE;
        return Math.sin(angle + random * Math.PI) * spiralRadius;

      default:
        return THREE.MathUtils.mapLinear(random, 0, 1, -Y_DISTANCE, Y_DISTANCE);
    }
  }

  // Create funnel object (desktop mode)
  function createFunnelObject(
    texture: THREE.Texture,
    geometry: THREE.PlaneGeometry,
    direction: "left-to-right" | "right-to-left",
    index: number,
    totalObjects: number,
    scene: THREE.Scene
  ): FunnelObject {
    const material = createBaseMaterial(texture);
    const mesh = new THREE.Mesh(geometry, material);

    const x = direction === "left-to-right" ? -X_DISTANCE : X_DISTANCE;
    const y = getImprovedYDistribution(
      index,
      direction,
      totalObjects,
      "gaussian"
    );

    const z =
      direction === "left-to-right" ? 0.0001 * index : 0.0001 * (index + 100);

    mesh.position.set(x, y, z);
    scene.add(mesh);

    return {
      mesh,
      startPosition: { x, y, z },
      offset: seededRandom(index * (direction === "left-to-right" ? 456 : 987)),
      direction,
    };
  }

  // Create mobile funnel object (bottom-to-top)
  function createMobileFunnelObject(
    texture: THREE.Texture,
    geometry: THREE.PlaneGeometry,
    index: number,
    scene: THREE.Scene
  ): FunnelObject {
    const material = createBaseMaterial(texture);
    const mesh = new THREE.Mesh(geometry, material);

    const x = THREE.MathUtils.mapLinear(
      seededRandom(index * 345),
      0,
      1,
      -MOBILE_X_VARIANCE,
      MOBILE_X_VARIANCE
    );
    const y = -MOBILE_Y_DISTANCE;
    const z = 0.0001 * index;

    mesh.position.set(x, y, z);
    scene.add(mesh);

    return {
      mesh,
      startPosition: { x, y, z },
      offset: seededRandom(index * 678),
      direction: "bottom-to-top",
    };
  }

  // Calculate X position based on direction and progress
  function calculateXPosition(
    direction: "left-to-right" | "right-to-left",
    progress: number
  ): number {
    if (direction === "left-to-right") {
      return THREE.MathUtils.mapLinear(progress, 0, 1, -X_DISTANCE, 0);
    } else {
      return THREE.MathUtils.mapLinear(progress, 0, 1, X_DISTANCE, 0);
    }
  }

  // Calculate Y position with convergence and noise
  function calculateYPosition(
    direction: "left-to-right" | "right-to-left",
    x: number,
    startY: number,
    noiseOffset: number
  ): number {
    let normalizedX: number;
    if (direction === "left-to-right") {
      // x vai de -6 para 0, normalizar para 0 a 1
      normalizedX = THREE.MathUtils.mapLinear(x, -6, 0, 0, 1);
    } else {
      // x vai de 6 para 0, normalizar para 0 a 1
      normalizedX = THREE.MathUtils.mapLinear(x, 6, 0, 0, 1);
    }

    // Criar curva parabólica: y = ax² + bx + c
    // Queremos que a curva passe por (0, startY) e (1, 0)
    // E tenha um ponto de controle que crie a curvatura desejada

    // Fator de curvatura - valores maiores = curva mais pronunciada
    const curvatureFactor = 2.0;

    // Aplicar transformação parabólica
    const curveY = startY * Math.pow(1 - normalizedX, curvatureFactor);

    return curveY + noiseOffset;
  }

  // Calculate scale based on position (desktop)
  function calculateScale(
    direction: "left-to-right" | "right-to-left",
    x: number
  ): number {
    if (direction === "left-to-right") {
      return THREE.MathUtils.mapLinear(x, -X_DISTANCE, 0, 1, 0.2);
    } else {
      return THREE.MathUtils.mapLinear(x, X_DISTANCE, 0, 1, 0.2);
    }
  }

  // Mobile-specific calculation functions
  function calculateMobileYPosition(progress: number): number {
    return THREE.MathUtils.mapLinear(
      progress,
      0,
      1,
      -MOBILE_Y_DISTANCE,
      MOBILE_Y_DISTANCE
    );
  }

  function calculateMobileScale(y: number): number {
    return THREE.MathUtils.mapLinear(
      y,
      -MOBILE_Y_DISTANCE,
      MOBILE_Y_DISTANCE,
      1,
      0.3
    );
  }

  // Type guard to check if object is desktop type
  function isDesktopObject(
    object: FunnelObject
  ): object is FunnelObject & { direction: "left-to-right" | "right-to-left" } {
    return (
      object.direction === "left-to-right" ||
      object.direction === "right-to-left"
    );
  }

  // Type guard to check if object is mobile type
  function isMobileObject(
    object: FunnelObject
  ): object is FunnelObject & { direction: "bottom-to-top" } {
    return object.direction === "bottom-to-top";
  }

  // Animate individual object (desktop)
  function updateObject(
    object: FunnelObject & { direction: "left-to-right" | "right-to-left" },
    index: number,
    progress: number
  ): void {
    const { mesh, offset, direction, startPosition } = object;
    const uniqueProgress = (progress + offset) % 1;

    const x = calculateXPosition(direction, uniqueProgress);

    const noiseInput = uniqueProgress * Math.PI * 2;
    const yOffset =
      noise(Math.cos(noiseInput) + index, Math.sin(noiseInput)) * 0.0001;

    const y = calculateYPosition(direction, x, startPosition.y, yOffset);

    const scale = calculateScale(direction, x);
    const opacity = THREE.MathUtils.clamp(
      THREE.MathUtils.mapLinear(Math.abs(x), 1.5, 0, 1, 0.01),
      0.01,
      1
    );

    // Only update material if opacity changed significantly (threshold: 0.01)
    if (object.cachedOpacity === undefined || Math.abs(object.cachedOpacity - opacity) > 0.01) {
      (mesh.material as THREE.MeshBasicMaterial).opacity = opacity;
      (mesh.material as THREE.MeshBasicMaterial).needsUpdate = true;
      object.cachedOpacity = opacity;
    }

    mesh.position.x = x;
    mesh.position.y = y;
    mesh.scale.set(scale, scale, 1);
  }

  // Animate individual object (mobile)
  function updateMobileObject(
    object: FunnelObject & { direction: "bottom-to-top" },
    index: number,
    progress: number
  ): void {
    const { mesh, offset, startPosition } = object;
    const uniqueProgress = (progress + offset) % 1;

    const y = calculateMobileYPosition(uniqueProgress);

    const noiseInput = uniqueProgress * Math.PI * 2;
    const xOffset =
      noise(Math.cos(noiseInput) + index, Math.sin(noiseInput)) * 0.01;
    const x =
      THREE.MathUtils.mapLinear(
        y,
        -MOBILE_Y_DISTANCE,
        MOBILE_Y_DISTANCE,
        startPosition.x,
        0
      ) + xOffset;

    const scale = calculateMobileScale(y);
    const opacity = Math.max(
      THREE.MathUtils.mapLinear(
        Math.abs(y),
        MOBILE_Y_DISTANCE * 0.5,
        MOBILE_Y_DISTANCE,
        1,
        0
      ),
      0.1
    );

    // Only update material if opacity changed significantly (threshold: 0.01)
    if (object.cachedOpacity === undefined || Math.abs(object.cachedOpacity - opacity) > 0.01) {
      (mesh.material as THREE.MeshBasicMaterial).opacity = opacity;
      (mesh.material as THREE.MeshBasicMaterial).needsUpdate = true;
      object.cachedOpacity = opacity;
    }

    mesh.position.x = x;
    mesh.position.y = y;
    mesh.scale.set(scale, scale, 1);
  }

  function getCanvasDimensions(canvas: HTMLCanvasElement): {
    width: number;
    height: number;
  } {
    const rect = canvas.getBoundingClientRect();
    let width = rect.width || canvas.clientWidth;
    let height = rect.height || canvas.clientHeight;

    if (width <= 0 || height <= 0) {
      const parent = canvas.parentElement;
      if (parent) {
        const parentRect = parent.getBoundingClientRect();
        const paddingOffset = 32;
        width = Math.max(parentRect.width - paddingOffset, 1);
        height = Math.max(parentRect.height - paddingOffset, 1);
      }
    }

    return {
      width: width || 1,
      height: height || 1,
    };
  }

  // Main initialization function
  async function initThreeFunnel() {
    const canvas = document.getElementById(
      "three-funnel-canvas"
    ) as HTMLCanvasElement;
    if (!canvas) return;

    let retries = 0;
    const maxRetries = 10;
    let dimensions = getCanvasDimensions(canvas);

    while (
      (dimensions.width <= 1 || dimensions.height <= 1) &&
      retries < maxRetries
    ) {
      await new Promise((resolve) => setTimeout(resolve, 100));
      dimensions = getCanvasDimensions(canvas);
      retries++;
    }

    const { width, height } = dimensions;

    canvas.width = width;
    canvas.height = height;

    const renderer = new THREE.WebGLRenderer({
      canvas,
      antialias: !isMobile, // Disable antialiasing on mobile for performance
      alpha: true,
    });
    renderer.setSize(width, height);
    // Reduce pixel ratio on mobile for better performance
    renderer.setPixelRatio(
      isMobile ? Math.min(window.devicePixelRatio, 2) : window.devicePixelRatio
    );
    renderer.setClearColor(0x000000, 0);
    renderer.sortObjects = true;

    const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
    camera.position.set(0, 0, 8);
    camera.lookAt(0, 0, 0);

    const scene = new THREE.Scene();

    const textureLoader = new THREE.TextureLoader();
    const LOOP_DURATION = isMobile ? 25000 : 40000; // Faster animation on mobile

    interface LoadedTextureData {
      texture: THREE.Texture;
      width: number;
      height: number;
      index: number;
    }

    let objects: FunnelObject[] = [];

    const createGeometry = (
      width: number,
      height: number
    ): THREE.PlaneGeometry => {
      return new THREE.PlaneGeometry(width, height);
    };
    const loadTexturePromises = textureDefinitions.map(
      (textureDefinition, i) => {
        return new Promise<LoadedTextureData | null>((resolve) => {
          const texture = textureLoader.load(
            textureDefinition.path,
            () => {
              const aspectRatio = texture.image.width / texture.image.height;
              const height = textureDefinition.width / aspectRatio;

              resolve({
                texture,
                width: textureDefinition.width,
                height: height,
                index: i,
              });
            },
            undefined,
            (error: unknown) => {
              console.error(
                `Error loading texture ${i + 1}:`,
                textureDefinition.path,
                error
              );
              resolve(null);
            }
          );
        });
      }
    );

    const loadedTextureData = await Promise.all(loadTexturePromises);
    const validTextureData = loadedTextureData.filter(
      (data): data is NonNullable<typeof data> => data !== null
    );

    // Function to create objects based on current mode
    function createObjectsForMode(mode: "desktop" | "mobile") {
      // Clear existing objects
      objects.forEach((obj) => scene.remove(obj.mesh));
      objects = [];

      const dataToUse =
        mode === "mobile"
          ? validTextureData.slice(0, MOBILE_TEXTURE_COUNT)
          : validTextureData;

      for (const { texture, width, height, index: i } of dataToUse) {
        const geometry = createGeometry(width, height);

        if (mode === "desktop") {
          const leftObject = createFunnelObject(
            texture,
            geometry,
            "left-to-right",
            i,
            validTextureData.length,
            scene
          );
          objects.push(leftObject);

          const rightObject = createFunnelObject(
            texture,
            geometry.clone(),
            "right-to-left",
            i,
            validTextureData.length,
            scene
          );
          objects.push(rightObject);
        } else {
          const mobileObject = createMobileFunnelObject(
            texture,
            geometry,
            i,
            scene
          );
          objects.push(mobileObject);
        }
      }
    }

    // Initialize objects for current mode
    createObjectsForMode(isMobile ? "mobile" : "desktop");

    let startTime = Date.now();
    let pausedTime = 0;
    let animationFrameId: number | null = null;
    let isAnimating = false;

    function animate() {
      if (!isAnimating) return;

      const currentTime = Date.now();
      const elapsed = currentTime - startTime - pausedTime;
      const progress = (elapsed / LOOP_DURATION) % 1;

      objects.forEach((object, index) => {
        if (isMobileObject(object)) {
          updateMobileObject(object, index, progress);
        } else if (isDesktopObject(object)) {
          updateObject(object, index, progress);
        }
      });

      renderer.render(scene, camera);
      animationFrameId = requestAnimationFrame(animate);
    }

    function pause() {
      if (isAnimating && animationFrameId !== null) {
        isAnimating = false;
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
        pausedTime = Date.now() - startTime - pausedTime;
      }
    }

    function resume() {
      if (!isAnimating) {
        isAnimating = true;
        startTime = Date.now() - pausedTime;
        animate();
      }
    }

    // IntersectionObserver to pause/resume animation when canvas is not visible
    const intersectionObserver = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            resume();
          } else {
            pause();
          }
        });
      },
      { threshold: 0.1 } // Start animation when at least 10% of canvas is visible
    );

    intersectionObserver.observe(canvas);

    // Page Visibility API to pause/resume when user switches tabs
    const handleVisibilityChange = () => {
      if (document.hidden) {
        pause();
      } else {
        // Check if canvas is in viewport before resuming
        const rect = canvas.getBoundingClientRect();
        const isInViewport =
          rect.top < window.innerHeight && rect.bottom > 0;
        if (isInViewport) {
          resume();
        }
      }
    };

    document.addEventListener("visibilitychange", handleVisibilityChange);

    // Start animation initially only if canvas is visible
    const rect = canvas.getBoundingClientRect();
    const isInitiallyVisible = rect.top < window.innerHeight && rect.bottom > 0;
    if (isInitiallyVisible) {
      isAnimating = true;
      animate();
    }

    let currentWidth = width;
    let currentHeight = height;

    function onWindowResize() {
      const clientWidth = window.innerWidth;
      const clientHeight = window.innerHeight;

      if (clientWidth === currentWidth && clientHeight === currentHeight) {
        return;
      }

      if (clientWidth <= 0 || clientHeight <= 0) {
        return;
      }

      // Check if mode changed
      const newIsMobile = clientWidth <= MOBILE_BREAKPOINT;
      if (newIsMobile !== isMobile) {
        isMobile = newIsMobile;
        createObjectsForMode(isMobile ? "mobile" : "desktop");
      }

      currentWidth = clientWidth;
      currentHeight = clientHeight;

      camera.aspect = clientWidth / clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(clientWidth, clientHeight);
      // Adjust pixel ratio based on mode
      renderer.setPixelRatio(
        isMobile
          ? Math.min(window.devicePixelRatio, 2)
          : window.devicePixelRatio
      );
    }

    // Debounce resize handler to avoid excessive calls
    let resizeTimeout: number | null = null;
    function debouncedResize() {
      if (resizeTimeout !== null) {
        clearTimeout(resizeTimeout);
      }
      resizeTimeout = window.setTimeout(() => {
        onWindowResize();
        resizeTimeout = null;
      }, 150);
    }

    if (typeof ResizeObserver !== "undefined") {
      const resizeObserver = new ResizeObserver(() => {
        debouncedResize();
      });
      resizeObserver.observe(canvas);
    }

    window.addEventListener("resize", debouncedResize);

    window.addEventListener("orientationchange", () => {
      // Use shorter timeout for orientation change since it's a major layout shift
      setTimeout(onWindowResize, 100);
    });

    return () => {
      pause();
      if (resizeTimeout !== null) {
        clearTimeout(resizeTimeout);
      }
      intersectionObserver.disconnect();
      document.removeEventListener("visibilitychange", handleVisibilityChange);
      window.removeEventListener("resize", debouncedResize);
      window.removeEventListener("orientationchange", onWindowResize);
      renderer.dispose();
      scene.clear();
    };
  }

  // Initialize when page loads
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initThreeFunnel);
  } else {
    initThreeFunnel();
  }
</script>
