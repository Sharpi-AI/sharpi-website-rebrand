---

---

<canvas
  id="three-funnel-canvas"
  class="absolute inset-0 w-full h-full block"
  style="width: 100%; height: 100%; display: block;"></canvas>

<script>
  import * as THREE from "three";
  import { createNoise2D } from "simplex-noise";

  const noise = createNoise2D();

  // Distances calculated dynamically based on viewport size
  let X_DISTANCE = 8;
  let Y_DISTANCE = 5;
  const Y_OFFSET = -1.5; // Controla o deslocamento vertical de todos os objetos (positivo = para cima, negativo = para baixo)

  const MOBILE_BREAKPOINT = 768;
  const MOBILE_Y_DISTANCE = 1;
  const MOBILE_Y_OFFSET = -2.5; // Controla o deslocamento vertical no mobile (independente do desktop)
  const MOBILE_X_VARIANCE = 3.5;
  const MOBILE_TEXTURE_COUNT = 12;

  // Animation constants
  const Z_INDEX_SPACING = 0.01;
  const Z_OFFSET_RIGHT = 100;
  const OPACITY_CHANGE_THRESHOLD = 0.01;
  const CURVATURE_FACTOR = 2.0;
  const MIN_SCALE = 0.2;
  const MIN_OPACITY = 0.01;
  const DESKTOP_OPACITY_FADE_START = 3;
  const MOBILE_OPACITY_FADE_START = 0.75;
  const MOBILE_MIN_OPACITY = 0.1;
  const MOBILE_NOISE_SCALE = 0.01;
  const DESKTOP_NOISE_SCALE = 0.0001;
  const MOBILE_SCALE_MIN = 0.3;

  let isMobile = window.innerWidth <= MOBILE_BREAKPOINT;

  interface TextureData {
    path: string;
    width: number;
  }

  interface FunnelObject {
    mesh: THREE.Mesh;
    startPosition: { x: number; y: number; z: number };
    offset: number;
    direction: "left-to-right" | "right-to-left" | "bottom-to-top";
    cachedOpacity?: number;
  }

  const textureDefinitions: TextureData[] = [
    { path: "/assets/medias/index/hero/image-01.png", width: 1.0 },
    { path: "/assets/medias/index/hero/image-02.png", width: 0.8 },
    { path: "/assets/medias/index/hero/image-03.png", width: 1.2 },
    { path: "/assets/medias/index/hero/image-04.png", width: 0.9 },
    { path: "/assets/medias/index/hero/image-05.png", width: 1.1 },
    { path: "/assets/medias/index/hero/image-06.png", width: 0.7 },
    { path: "/assets/medias/index/hero/image-07.png", width: 1.3 },
    { path: "/assets/medias/index/hero/image-08.png", width: 0.8 },
    { path: "/assets/medias/index/hero/image-09.png", width: 1.0 },
    { path: "/assets/medias/index/hero/image-10.png", width: 0.9 },
    { path: "/assets/medias/index/hero/image-11.png", width: 1.1 },
    { path: "/assets/medias/index/hero/image-12.png", width: 0.6 },
    { path: "/assets/medias/index/hero/image-13.png", width: 1.2 },
    { path: "/assets/medias/index/hero/image-14.png", width: 0.8 },
    { path: "/assets/medias/index/hero/image-15.png", width: 1.0 },
    { path: "/assets/medias/index/hero/image-16.png", width: 0.9 },
    { path: "/assets/medias/index/hero/image-17.png", width: 1.1 },
  ];

  // Calculate dynamic distances based on viewport size
  function calculateDistances(width: number, height: number): {
    xDistance: number;
    yDistance: number;
  } {
    // Base distances (for reference viewport ~1920x1080)
    const BASE_WIDTH = 1440;
    const BASE_HEIGHT = 900;
    const BASE_X_DISTANCE = 10;
    const BASE_Y_DISTANCE = 4;

    // Calculate scaling factors
    const widthScale = width / BASE_WIDTH;
    const heightScale = height / BASE_HEIGHT;

    // Scale distances proportionally with limits
    const xDistance = THREE.MathUtils.clamp(
      BASE_X_DISTANCE * Math.sqrt(widthScale),
      6,  // min: telas pequenas
      12  // max: telas muito grandes
    );

    const yDistance = THREE.MathUtils.clamp(
      BASE_Y_DISTANCE * Math.sqrt(heightScale),
      2,  // min: telas pequenas
      5   // max: telas muito grandes
    );

    return { xDistance, yDistance };
  }

  // Seeded random function for deterministic positioning
  function seededRandom(seed: number): number {
    const x = Math.sin(seed) * 10000;
    return x - Math.floor(x);
  }

  // Create base material for objects
  function createBaseMaterial(texture: THREE.Texture): THREE.MeshBasicMaterial {
    return new THREE.MeshBasicMaterial({
      map: texture,
      side: THREE.DoubleSide,
      transparent: true,
      opacity: 1,
      color: new THREE.Color(0xffffff),
    });
  }

  // Create and configure base mesh
  function createBaseMesh(
    texture: THREE.Texture,
    geometry: THREE.PlaneGeometry,
    position: { x: number; y: number; z: number },
    scene: THREE.Scene
  ): THREE.Mesh {
    const material = createBaseMaterial(texture);
    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.set(position.x, position.y, position.z);
    scene.add(mesh);
    return mesh;
  }

  function getImprovedYDistribution(
    index: number,
    direction: "left-to-right" | "right-to-left",
    totalObjects: number,
    distributionType: "uniform" | "gaussian" | "layered" | "spiral" = "layered"
  ): number {
    const seed = index * (direction === "left-to-right" ? 123 : 789);
    const random = seededRandom(seed);

    switch (distributionType) {
      case "uniform":
        // Distribuição uniforme simples (original)
        return THREE.MathUtils.mapLinear(random, 0, 1, -Y_DISTANCE, Y_DISTANCE);

      case "gaussian":
        // Distribuição gaussiana (mais objetos no centro)
        const u1 = seededRandom(seed + 1000);
        const u2 = seededRandom(seed + 2000);
        const gaussian =
          Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
        return THREE.MathUtils.clamp(
          gaussian * (Y_DISTANCE * 0.5),
          -Y_DISTANCE,
          Y_DISTANCE
        );

      case "layered":
        // Distribuição em camadas para melhor cobertura
        const numLayers = Math.ceil(Math.sqrt(totalObjects / 2)); // Layers baseadas no número de objetos
        const layerHeight = (Y_DISTANCE * 2) / numLayers;
        const layerIndex = Math.floor(random * numLayers);
        const layerCenter = -Y_DISTANCE + (layerIndex + 0.5) * layerHeight;

        // Adicionar variação dentro da camada
        const layerVariation = seededRandom(seed + 3000) * layerHeight * 0.3;
        return layerCenter + layerVariation;

      case "spiral":
        // Distribuição em espiral para criar padrão mais orgânico
        const spiralTurns = 2; // Número de voltas da espiral
        const angle = (index / totalObjects) * spiralTurns * Math.PI * 2;
        const spiralRadius = (index / totalObjects) * Y_DISTANCE;
        return Math.sin(angle + random * Math.PI) * spiralRadius;

      default:
        return THREE.MathUtils.mapLinear(random, 0, 1, -Y_DISTANCE, Y_DISTANCE);
    }
  }

  // Create funnel object (desktop mode)
  function createFunnelObject(
    texture: THREE.Texture,
    geometry: THREE.PlaneGeometry,
    direction: "left-to-right" | "right-to-left",
    index: number,
    totalObjects: number,
    scene: THREE.Scene
  ): FunnelObject {
    const x = direction === "left-to-right" ? -X_DISTANCE : X_DISTANCE;
    const y = getImprovedYDistribution(index, direction, totalObjects, "gaussian");
    const z = direction === "left-to-right"
      ? Z_INDEX_SPACING * index
      : Z_INDEX_SPACING * (index + Z_OFFSET_RIGHT);

    const mesh = createBaseMesh(texture, geometry, { x, y: y + Y_OFFSET, z }, scene);

    return {
      mesh,
      startPosition: { x, y: y + Y_OFFSET, z },
      offset: seededRandom(index * (direction === "left-to-right" ? 456 : 987)),
      direction,
    };
  }

  // Create mobile funnel object (bottom-to-top)
  function createMobileFunnelObject(
    texture: THREE.Texture,
    geometry: THREE.PlaneGeometry,
    index: number,
    scene: THREE.Scene
  ): FunnelObject {
    // Criar "faixas" de entrada para melhor distribuição
    const numLanes = 3; // Número de faixas horizontais
    const laneIndex = index % numLanes;

    // Posição X baseada na faixa com variação adicional
    const laneWidth = (MOBILE_X_VARIANCE * 2) / numLanes;
    const laneCenter = -MOBILE_X_VARIANCE + (laneIndex + 0.5) * laneWidth;
    const xVariation = (seededRandom(index * 345) - 0.5) * laneWidth * 0.6;
    const x = laneCenter + xVariation;

    // Criar "ondas" de entrada: cards começam em diferentes posições Y
    // Isso evita que todos comecem juntos de baixo
    const waveOffset = (index / MOBILE_TEXTURE_COUNT) * MOBILE_Y_DISTANCE * 0.8;
    const y = -MOBILE_Y_DISTANCE - waveOffset;

    const z = Z_INDEX_SPACING * index;

    const mesh = createBaseMesh(texture, geometry, { x, y: y + MOBILE_Y_OFFSET, z }, scene);

    return {
      mesh,
      startPosition: { x, y: y + MOBILE_Y_OFFSET, z },
      offset: seededRandom(index * 678),
      direction: "bottom-to-top",
    };
  }

  // Calculate X position based on direction and progress
  function calculateXPosition(
    direction: "left-to-right" | "right-to-left",
    progress: number
  ): number {
    const startX = direction === "left-to-right" ? -X_DISTANCE : X_DISTANCE;
    return THREE.MathUtils.mapLinear(progress, 0, 1, startX, 0);
  }

  // Calculate Y position with convergence and noise
  function calculateYPosition(
    direction: "left-to-right" | "right-to-left",
    x: number,
    startY: number,
    noiseOffset: number
  ): number {
    const startX = direction === "left-to-right" ? -X_DISTANCE : X_DISTANCE;
    const normalizedX = THREE.MathUtils.mapLinear(x, startX, 0, 0, 1);

    // Aplicar transformação parabólica para criar curva de convergência
    const curveY = startY * Math.pow(1 - normalizedX, CURVATURE_FACTOR);

    return curveY + noiseOffset;
  }

  // Calculate scale based on position (desktop)
  function calculateScale(
    direction: "left-to-right" | "right-to-left",
    x: number
  ): number {
    const startX = direction === "left-to-right" ? -X_DISTANCE : X_DISTANCE;
    return THREE.MathUtils.mapLinear(x, startX, 0, 1, MIN_SCALE);
  }

  // Mobile-specific calculation functions
  function calculateMobileYPosition(progress: number): number {
    return THREE.MathUtils.mapLinear(
      progress,
      0,
      1,
      -MOBILE_Y_DISTANCE,
      MOBILE_Y_DISTANCE
    );
  }

  function calculateMobileScale(y: number): number {
    // Usar curva suave (ease-out) para melhor transição de escala
    const normalizedY = THREE.MathUtils.mapLinear(
      y,
      -MOBILE_Y_DISTANCE,
      MOBILE_Y_DISTANCE,
      0,
      1
    );
    const easedProgress = 1 - Math.pow(1 - normalizedY, 2);
    return THREE.MathUtils.mapLinear(
      easedProgress,
      0,
      1,
      1,
      MOBILE_SCALE_MIN
    );
  }

  // Type guard to check if object is desktop type
  function isDesktopObject(
    object: FunnelObject
  ): object is FunnelObject & { direction: "left-to-right" | "right-to-left" } {
    return (
      object.direction === "left-to-right" ||
      object.direction === "right-to-left"
    );
  }

  // Type guard to check if object is mobile type
  function isMobileObject(
    object: FunnelObject
  ): object is FunnelObject & { direction: "bottom-to-top" } {
    return object.direction === "bottom-to-top";
  }

  // Update mesh opacity only if changed significantly
  function updateMeshOpacity(object: FunnelObject, opacity: number): void {
    if (
      object.cachedOpacity === undefined ||
      Math.abs(object.cachedOpacity - opacity) > OPACITY_CHANGE_THRESHOLD
    ) {
      (object.mesh.material as THREE.MeshBasicMaterial).opacity = opacity;
      (object.mesh.material as THREE.MeshBasicMaterial).needsUpdate = true;
      object.cachedOpacity = opacity;
    }
  }

  // Calculate noise offset for animation
  function calculateNoiseOffset(
    progress: number,
    index: number,
    scale: number
  ): number {
    const noiseInput = progress * Math.PI * 2;
    return noise(Math.cos(noiseInput) + index, Math.sin(noiseInput)) * scale;
  }

  // Animate individual object (desktop)
  function updateObject(
    object: FunnelObject & { direction: "left-to-right" | "right-to-left" },
    index: number,
    progress: number
  ): void {
    const { mesh, offset, direction, startPosition } = object;
    const uniqueProgress = (progress + offset) % 1;

    const x = calculateXPosition(direction, uniqueProgress);
    const yOffset = calculateNoiseOffset(uniqueProgress, index, DESKTOP_NOISE_SCALE);
    const y = calculateYPosition(direction, x, startPosition.y, yOffset);

    const scale = calculateScale(direction, x);
    const opacity = THREE.MathUtils.clamp(
      THREE.MathUtils.mapLinear(Math.abs(x), DESKTOP_OPACITY_FADE_START, 0, 1, MIN_OPACITY),
      MIN_OPACITY,
      1
    );

    updateMeshOpacity(object, opacity);

    mesh.position.x = x;
    mesh.position.y = y + Y_OFFSET;
    mesh.scale.set(scale, scale, 1);
  }

  // Animate individual object (mobile)
  function updateMobileObject(
    object: FunnelObject & { direction: "bottom-to-top" },
    index: number,
    progress: number
  ): void {
    const { mesh, offset, startPosition } = object;
    const uniqueProgress = (progress + offset) % 1;

    const y = calculateMobileYPosition(uniqueProgress);
    const xOffset = calculateNoiseOffset(uniqueProgress, index, MOBILE_NOISE_SCALE);
    const x = THREE.MathUtils.mapLinear(
      y,
      -MOBILE_Y_DISTANCE,
      MOBILE_Y_DISTANCE,
      startPosition.x,
      0
    ) + xOffset;

    const scale = calculateMobileScale(y);

    // Curva de opacidade melhorada com fade suave nas extremidades
    const normalizedY = Math.abs(y) / MOBILE_Y_DISTANCE;
    const fadeStart = MOBILE_OPACITY_FADE_START;

    let opacity: number;
    if (normalizedY < fadeStart) {
      opacity = 1;
    } else {
      // Usar ease-in para fade mais suave
      const fadeProgress = (normalizedY - fadeStart) / (1 - fadeStart);
      opacity = Math.max(
        1 - Math.pow(fadeProgress, 1.5),
        MOBILE_MIN_OPACITY
      );
    }

    updateMeshOpacity(object, opacity);

    mesh.position.x = x;
    mesh.position.y = y + MOBILE_Y_OFFSET;
    mesh.scale.set(scale, scale, 1);
  }

  function getCanvasDimensions(canvas: HTMLCanvasElement): {
    width: number;
    height: number;
  } {
    const rect = canvas.getBoundingClientRect();
    let width = rect.width || canvas.clientWidth;
    let height = rect.height || canvas.clientHeight;

    if (width <= 0 || height <= 0) {
      const parent = canvas.parentElement;
      if (parent) {
        const parentRect = parent.getBoundingClientRect();
        const paddingOffset = 32;
        width = Math.max(parentRect.width - paddingOffset, 1);
        height = Math.max(parentRect.height - paddingOffset, 1);
      }
    }

    return {
      width: width || 1,
      height: height || 1,
    };
  }

  // Main initialization function
  async function initThreeFunnel() {
    const canvas = document.getElementById(
      "three-funnel-canvas"
    ) as HTMLCanvasElement;
    if (!canvas) return;

    let retries = 0;
    const maxRetries = 10;
    let dimensions = getCanvasDimensions(canvas);

    while (
      (dimensions.width <= 1 || dimensions.height <= 1) &&
      retries < maxRetries
    ) {
      await new Promise((resolve) => setTimeout(resolve, 100));
      dimensions = getCanvasDimensions(canvas);
      retries++;
    }

    const { width, height } = dimensions;

    // Calculate dynamic distances based on viewport size
    const distances = calculateDistances(width, height);
    X_DISTANCE = distances.xDistance;
    Y_DISTANCE = distances.yDistance;

    canvas.width = width;
    canvas.height = height;

    const renderer = new THREE.WebGLRenderer({
      canvas,
      antialias: !isMobile, // Disable antialiasing on mobile for performance
      alpha: true,
    });
    renderer.setSize(width, height);
    // Reduce pixel ratio on mobile for better performance
    renderer.setPixelRatio(
      isMobile ? Math.min(window.devicePixelRatio, 2) : window.devicePixelRatio
    );
    renderer.setClearColor(0x000000, 0);
    renderer.sortObjects = true;

    const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
    camera.position.set(0, 0, 8);
    camera.lookAt(0, 0, 0);

    const scene = new THREE.Scene();

    const textureLoader = new THREE.TextureLoader();
    const LOOP_DURATION = isMobile ? 25000 : 40000; // Faster animation on mobile

    interface LoadedTextureData {
      texture: THREE.Texture;
      width: number;
      height: number;
      index: number;
    }

    let objects: FunnelObject[] = [];

    function createGeometry(
      width: number,
      height: number
    ): THREE.PlaneGeometry {
      return new THREE.PlaneGeometry(width, height);
    }

    const loadTexturePromises = textureDefinitions.map(
      (textureDefinition, i) => {
        return new Promise<LoadedTextureData | null>((resolve) => {
          const texture = textureLoader.load(
            textureDefinition.path,
            () => {
              const aspectRatio = texture.image.width / texture.image.height;
              const height = textureDefinition.width / aspectRatio;

              resolve({
                texture,
                width: textureDefinition.width,
                height: height,
                index: i,
              });
            },
            undefined,
            (error: unknown) => {
              console.error(
                `Error loading texture ${i + 1}:`,
                textureDefinition.path,
                error
              );
              resolve(null);
            }
          );
        });
      }
    );

    const loadedTextureData = await Promise.all(loadTexturePromises);
    const validTextureData = loadedTextureData.filter(
      (data): data is NonNullable<typeof data> => data !== null
    );

    // Function to create objects based on current mode
    function createObjectsForMode(mode: "desktop" | "mobile") {
      // Clear existing objects
      objects.forEach((obj) => scene.remove(obj.mesh));
      objects = [];

      const dataToUse =
        mode === "mobile"
          ? validTextureData.slice(0, MOBILE_TEXTURE_COUNT)
          : validTextureData;

      for (const { texture, width, height, index: i } of dataToUse) {
        const geometry = createGeometry(width, height);

        if (mode === "desktop") {
          const leftObject = createFunnelObject(
            texture,
            geometry,
            "left-to-right",
            i,
            validTextureData.length,
            scene
          );
          objects.push(leftObject);

          const rightObject = createFunnelObject(
            texture,
            geometry.clone(),
            "right-to-left",
            i,
            validTextureData.length,
            scene
          );
          objects.push(rightObject);
        } else {
          const mobileObject = createMobileFunnelObject(
            texture,
            geometry,
            i,
            scene
          );
          objects.push(mobileObject);
        }
      }
    }

    // Initialize objects for current mode
    createObjectsForMode(isMobile ? "mobile" : "desktop");

    let startTime = Date.now();
    let pausedTime = 0;
    let animationFrameId: number | null = null;
    let isAnimating = false;

    function animate() {
      if (!isAnimating) return;

      const currentTime = Date.now();
      const elapsed = currentTime - startTime - pausedTime;
      const progress = (elapsed / LOOP_DURATION) % 1;

      objects.forEach((object, index) => {
        if (isMobileObject(object)) {
          updateMobileObject(object, index, progress);
        } else if (isDesktopObject(object)) {
          updateObject(object, index, progress);
        }
      });

      renderer.render(scene, camera);
      animationFrameId = requestAnimationFrame(animate);
    }

    function pause() {
      if (isAnimating && animationFrameId !== null) {
        isAnimating = false;
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
        pausedTime = Date.now() - startTime - pausedTime;
      }
    }

    function resume() {
      if (!isAnimating) {
        isAnimating = true;
        startTime = Date.now() - pausedTime;
        animate();
      }
    }

    // IntersectionObserver to pause/resume animation when canvas is not visible
    const intersectionObserver = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            resume();
          } else {
            pause();
          }
        });
      },
      { threshold: 0.1 } // Start animation when at least 10% of canvas is visible
    );

    intersectionObserver.observe(canvas);

    // Page Visibility API to pause/resume when user switches tabs
    const handleVisibilityChange = () => {
      if (document.hidden) {
        pause();
      } else {
        // Check if canvas is in viewport before resuming
        const rect = canvas.getBoundingClientRect();
        const isInViewport =
          rect.top < window.innerHeight && rect.bottom > 0;
        if (isInViewport) {
          resume();
        }
      }
    };

    document.addEventListener("visibilitychange", handleVisibilityChange);

    // Start animation initially only if canvas is visible
    const rect = canvas.getBoundingClientRect();
    const isInitiallyVisible = rect.top < window.innerHeight && rect.bottom > 0;
    if (isInitiallyVisible) {
      isAnimating = true;
      animate();
    }

    let currentWidth = width;
    let currentHeight = height;
    let previousXDistance = X_DISTANCE;
    let previousYDistance = Y_DISTANCE;

    function onWindowResize() {
      const clientWidth = window.innerWidth;
      const clientHeight = window.innerHeight;

      // Early return if dimensions unchanged
      if (clientWidth === currentWidth && clientHeight === currentHeight) return;
      if (clientWidth <= 0 || clientHeight <= 0) return;

      // Check mode change
      const newIsMobile = clientWidth <= MOBILE_BREAKPOINT;
      const modeChanged = newIsMobile !== isMobile;
      if (modeChanged) isMobile = newIsMobile;

      // Check distances change for desktop mode
      const distancesChanged = !isMobile && (() => {
        const newDistances = calculateDistances(clientWidth, clientHeight);
        const DISTANCE_CHANGE_THRESHOLD = 0.1;

        const xChanged = Math.abs(newDistances.xDistance - previousXDistance) / previousXDistance > DISTANCE_CHANGE_THRESHOLD;
        const yChanged = Math.abs(newDistances.yDistance - previousYDistance) / previousYDistance > DISTANCE_CHANGE_THRESHOLD;

        if (xChanged || yChanged) {
          X_DISTANCE = newDistances.xDistance;
          Y_DISTANCE = newDistances.yDistance;
          previousXDistance = X_DISTANCE;
          previousYDistance = Y_DISTANCE;
          return true;
        }
        return false;
      })();

      // Recreate objects if needed
      if (modeChanged || distancesChanged) {
        createObjectsForMode(isMobile ? "mobile" : "desktop");
      }

      // Update dimensions and camera
      currentWidth = clientWidth;
      currentHeight = clientHeight;
      camera.aspect = clientWidth / clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(clientWidth, clientHeight);
      renderer.setPixelRatio(
        isMobile ? Math.min(window.devicePixelRatio, 2) : window.devicePixelRatio
      );
    }

    // Debounce resize handler to avoid excessive calls
    let resizeTimeout: number | null = null;
    function debouncedResize() {
      if (resizeTimeout !== null) {
        clearTimeout(resizeTimeout);
      }
      resizeTimeout = window.setTimeout(() => {
        onWindowResize();
        resizeTimeout = null;
      }, 150);
    }

    if (typeof ResizeObserver !== "undefined") {
      const resizeObserver = new ResizeObserver(() => {
        debouncedResize();
      });
      resizeObserver.observe(canvas);
    }

    window.addEventListener("resize", debouncedResize);

    window.addEventListener("orientationchange", () => {
      // Use shorter timeout for orientation change since it's a major layout shift
      setTimeout(onWindowResize, 100);
    });

    return () => {
      pause();
      if (resizeTimeout !== null) {
        clearTimeout(resizeTimeout);
      }
      intersectionObserver.disconnect();
      document.removeEventListener("visibilitychange", handleVisibilityChange);
      window.removeEventListener("resize", debouncedResize);
      window.removeEventListener("orientationchange", onWindowResize);
      renderer.dispose();
      scene.clear();
    };
  }

  // Initialize when page loads
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initThreeFunnel);
  } else {
    initThreeFunnel();
  }
</script>
