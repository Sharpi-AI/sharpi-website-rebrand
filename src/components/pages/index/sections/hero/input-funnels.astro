---
interface Props {
  id?: string;
}

const { id = "three-funnel-canvas" } = Astro.props;
---

<canvas
  id={id}
  class="absolute inset-0 w-full h-full block "
  style="width: 100%; height: 100%; display: block;"
  data-funnel-id={id}></canvas>

<script>
  import * as THREE from "three";
  import { createNoise2D } from "simplex-noise";
  import { GUI } from "lil-gui";

  const noise = createNoise2D();

  // ============================================================================
  // CONSTANTES GLOBAIS
  // ============================================================================

  const MOBILE_BREAKPOINT = 768;
  const Y_OFFSET = -1.5;
  const Z_INDEX_SPACING = 0.01;
  const Z_OFFSET_RIGHT = 100;
  const OPACITY_CHANGE_THRESHOLD = 0.01;
  const MIN_SCALE = 0.2;
  const MIN_OPACITY = 0.01;
  const CURVATURE_FACTOR = 2.0;
  const SEEDED_RANDOM_MULTIPLIER = 10000;

  // Constantes compartilhadas entre desktop e mobile
  const COMMON_LANE_VARIATION_FACTOR = 0.6;
  

  // ============================================================================
  // CONSTANTES POR PLATAFORMA
  // ============================================================================

  // Default values for reset functionality
  const DEFAULT_DESKTOP_CONFIG = {
    initial: { x: 8, y: 8 },
    objectsPerTexture: 2,
    numLanes: {
      y: 5,
      x: 5,
    },
    xLaneVariance: 1.0,
    xLaneIndexMultiplier: 2,
    yLaneVariationFactor: 0.4,
    xLaneVariationFactor: 0.4,
    yLaneEdgeConcentration: 0.7,
    opacityFadeStart: 3,
    noiseScale: 0.0001,
    loopDurationMs: 40000,
    seeds: {
      left: 456,
      right: 987,
      repetition: 1234,
      yLane: 999,
      yLaneRepetition: 555,
      xLane: 777,
      xLaneRepetition: 333,
      uniformLeft: 123,
      uniformRight: 789,
    },
    distributionY: {
      gaussianU1: 1000,
      gaussianU2: 2000,
      gaussianFactor: 0.5,
      layerVariation: 3000,
      layerVariationFactor: 0.3,
      spiralTurns: 2,
    },
  } as const;

  // Mutable config for lil-gui manipulation
  const DESKTOP_CONFIG = {
    initial: { x: 8, y: 8.5 },
    objectsPerTexture: 3,
    numLanes: {
      y: 4,
      x: 5,
    },
    xLaneVariance: 1.0,
    xLaneIndexMultiplier: 2,
    yLaneVariationFactor: 1,
    xLaneVariationFactor: 0.4,
    yLaneEdgeConcentration: 0.5,
    opacityFadeStart: 3,
    noiseScale: 0.0001,
    loopDurationMs: 80000,
    seeds: {
      left: 6234,
      right: 7636,
      repetition: 1234,
      yLane: 627,
      yLaneRepetition: 555,
      xLane: 777,
      xLaneRepetition: 333,
      uniformLeft: 123,
      uniformRight: 789,
    },
    distributionY: {
      gaussianU1: 1000,
      gaussianU2: 2000,
      gaussianFactor: 0.5,
      layerVariation: 3000,
      layerVariationFactor: 0.3,
      spiralTurns: 2,
    },
  };

  const MOBILE_CONFIG = {
    yDistance: 2.1,
    yOffset: 0,
    xVariance: 2,
    xOffset: -0.3,
    textureCount: 25,
    numLanes: {
      y: 5,
      x: 3,
    },
    yLaneVariationFactor: COMMON_LANE_VARIATION_FACTOR,
    xLaneVariationFactor: COMMON_LANE_VARIATION_FACTOR,
    yStartRangeMultiplier: 1.5,
    opacityFadeStart: 0.5,
    minOpacity: 0.1,
    noiseScale: 0.01,
    scaleMin: 0.4,
    fadeEaseExponent: 1.5,
    loopDurationMs: 20000,
    maxPixelRatio: 2,
    seeds: {
      xVariation: 345,
      offset: 678,
      yLane: 678,
      yLaneOffset: 9999,
    },
    height: {
      availablePercent: 0.4,
      maxPx: 500,
      toUnitsDivisor: 100,
    },
  } as const;

  // ============================================================================
  // CONSTANTES DE VIEWPORT
  // ============================================================================

  const VIEWPORT_CONFIG = {
    base: { width: 1440, height: 900 },
    distance: {
      baseX: 10,
      baseY: 8,
      minX: 6,
      maxX: 12,
      minY: 2,
      maxY: 10,
    },
  } as const;

  // ============================================================================
  // CONSTANTES DE CANVAS E RENDERER
  // ============================================================================

  const CANVAS_CONFIG = {
    paddingOffset: 32,
    minDimension: 1,
    init: {
      maxRetries: 10,
      retryDelayMs: 100,
    },
  } as const;

  const CAMERA_CONFIG = {
    fov: 50,
    near: 0.1,
    far: 1000,
    positionZ: 8,
  } as const;

  const RENDERER_CONFIG = {
    clearColor: 0x000000,
    clearAlpha: 0,
  } as const;

  // ============================================================================
  // CONSTANTES DE OBSERVERS E TIMING
  // ============================================================================

  const OBSERVER_CONFIG = {
    intersectionThreshold: 0.1,
    resizeDebounceMs: 150,
    orientationChangeDelayMs: 100,
    distanceChangeThreshold: 0.1,
  } as const;

  // ============================================================================
  // VARIÁVEIS DINÂMICAS
  // ============================================================================

  // Distâncias calculadas dinamicamente baseadas no tamanho da viewport
  let X_DISTANCE = DESKTOP_CONFIG.initial.x;
  let Y_DISTANCE = DESKTOP_CONFIG.initial.y;

  let isMobile = window.innerWidth <= MOBILE_BREAKPOINT;

  interface TextureData {
    path: string;
    width: number;
  }

  interface FunnelObject {
    mesh: THREE.Mesh;
    startPosition: { x: number; y: number; z: number };
    offset: number;
    direction: "left-to-right" | "right-to-left" | "bottom-to-top";
    cachedOpacity?: number;
  }

  const textureDefinitions: TextureData[] = [
    { path: "/assets/medias/index/hero/image-01.png", width: 1.0 },
    { path: "/assets/medias/index/hero/image-02.png", width: 0.8 },
    { path: "/assets/medias/index/hero/image-03.png", width: 1.2 },
    { path: "/assets/medias/index/hero/image-04.png", width: 0.9 },
    { path: "/assets/medias/index/hero/image-05.png", width: 1.1 },
    { path: "/assets/medias/index/hero/image-06.png", width: 0.7 },
    { path: "/assets/medias/index/hero/image-07.png", width: 1.3 },
    { path: "/assets/medias/index/hero/image-08.png", width: 0.8 },
    { path: "/assets/medias/index/hero/image-09.png", width: 1.0 },
    { path: "/assets/medias/index/hero/image-10.png", width: 0.9 },
    { path: "/assets/medias/index/hero/image-11.png", width: 1.1 },
    { path: "/assets/medias/index/hero/image-12.png", width: 0.6 },
    { path: "/assets/medias/index/hero/image-13.png", width: 1.2 },
    { path: "/assets/medias/index/hero/image-14.png", width: 0.8 },
    { path: "/assets/medias/index/hero/image-15.png", width: 1.0 },
    { path: "/assets/medias/index/hero/image-16.png", width: 0.9 },
    { path: "/assets/medias/index/hero/image-17.png", width: 1.1 },
  ];

  // Calculate dynamic distances based on viewport size
  function calculateDistances(width: number, height: number): {
    xDistance: number;
    yDistance: number;
  } {
    // Calculate scaling factors
    const widthScale = width / VIEWPORT_CONFIG.base.width;
    const heightScale = height / VIEWPORT_CONFIG.base.height;

    // Scale distances proportionally with limits
    const xDistance = THREE.MathUtils.clamp(
      VIEWPORT_CONFIG.distance.baseX * Math.sqrt(widthScale),
      VIEWPORT_CONFIG.distance.minX,
      VIEWPORT_CONFIG.distance.maxX
    );

    const yDistance = THREE.MathUtils.clamp(
      VIEWPORT_CONFIG.distance.baseY * Math.sqrt(heightScale),
      VIEWPORT_CONFIG.distance.minY,
      VIEWPORT_CONFIG.distance.maxY
    );

    return { xDistance, yDistance };
  }

  // Calculate adjusted mobile Y distance to avoid overlapping with notifications
  function getAdjustedMobileYDistance(): number {
    const viewportHeight = window.innerHeight;
    const availableHeight = Math.min(
      viewportHeight * MOBILE_CONFIG.height.availablePercent,
      MOBILE_CONFIG.height.maxPx
    );
    return Math.min(MOBILE_CONFIG.yDistance, availableHeight / MOBILE_CONFIG.height.toUnitsDivisor);
  }

  // Seeded random function for deterministic positioning
  function seededRandom(seed: number): number {
    const x = Math.sin(seed) * SEEDED_RANDOM_MULTIPLIER;
    return x - Math.floor(x);
  }

  // Create base material for objects
  function createBaseMaterial(texture: THREE.Texture): THREE.MeshBasicMaterial {
    return new THREE.MeshBasicMaterial({
      map: texture,
      side: THREE.DoubleSide,
      transparent: true,
      opacity: 1,
      color: new THREE.Color(0xffffff),
    });
  }

  // Create and configure base mesh
  function createBaseMesh(
    texture: THREE.Texture,
    geometry: THREE.PlaneGeometry,
    position: { x: number; y: number; z: number },
    scene: THREE.Scene
  ): THREE.Mesh {
    const material = createBaseMaterial(texture);
    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.set(position.x, position.y, position.z);
    scene.add(mesh);
    return mesh;
  }

  function getImprovedYDistribution(
    index: number,
    direction: "left-to-right" | "right-to-left",
    totalObjects: number,
    distributionType: "uniform" | "gaussian" | "layered" | "spiral" = "layered"
  ): number {
    const seedMultiplier = direction === "left-to-right"
      ? DESKTOP_CONFIG.seeds.uniformLeft
      : DESKTOP_CONFIG.seeds.uniformRight;
    const seed = index * seedMultiplier;
    const random = seededRandom(seed);

    switch (distributionType) {
      case "uniform":
        return THREE.MathUtils.mapLinear(random, 0, 1, -Y_DISTANCE, Y_DISTANCE);

      case "gaussian":
        const u1 = seededRandom(seed + DESKTOP_CONFIG.distributionY.gaussianU1);
        const u2 = seededRandom(seed + DESKTOP_CONFIG.distributionY.gaussianU2);
        const gaussian =
          Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
        return THREE.MathUtils.clamp(
          gaussian * (Y_DISTANCE * DESKTOP_CONFIG.distributionY.gaussianFactor),
          -Y_DISTANCE,
          Y_DISTANCE
        );

      case "layered":
        const numLayers = Math.ceil(Math.sqrt(totalObjects / 2));
        const layerHeight = (Y_DISTANCE * 2) / numLayers;
        const layerIndex = Math.floor(random * numLayers);
        const layerCenter = -Y_DISTANCE + (layerIndex + 0.5) * layerHeight;
        const layerVariation = seededRandom(seed + DESKTOP_CONFIG.distributionY.layerVariation) * layerHeight * DESKTOP_CONFIG.distributionY.layerVariationFactor;
        return layerCenter + layerVariation;

      case "spiral":
        const angle = (index / totalObjects) * DESKTOP_CONFIG.distributionY.spiralTurns * Math.PI * 2;
        const spiralRadius = (index / totalObjects) * Y_DISTANCE;
        return Math.sin(angle + random * Math.PI) * spiralRadius;

      default:
        return THREE.MathUtils.mapLinear(random, 0, 1, -Y_DISTANCE, Y_DISTANCE);
    }
  }

  function getDesktopYLaneDistribution(
    index: number,
    repetitionIndex: number,
    numLanes: number
  ): number {
    const seed = index * DESKTOP_CONFIG.seeds.yLane + repetitionIndex * DESKTOP_CONFIG.seeds.yLaneRepetition;
    const random = seededRandom(seed);
    
    let laneIndex: number;
    
    if (DESKTOP_CONFIG.yLaneEdgeConcentration > 0) {
      const concentration = DESKTOP_CONFIG.yLaneEdgeConcentration;
      
      let weightedPosition: number;
      
      const normalizedRandom = random;
      
      if (concentration < 0.5) {
        const curvePower = 1 + concentration * 4;
        weightedPosition = normalizedRandom < 0.5
          ? Math.pow(normalizedRandom * 2, curvePower) / 2
          : 1 - Math.pow((1 - normalizedRandom) * 2, curvePower) / 2;
      } else {
        const strongConcentration = (concentration - 0.5) * 2;
        const distanceFromCenter = Math.abs(normalizedRandom - 0.5) * 2;
        const edgePull = Math.pow(distanceFromCenter, 1 / (1 + strongConcentration * 3));
        
        if (normalizedRandom < 0.5) {
          weightedPosition = 0.5 - edgePull * 0.5;
        } else {
          weightedPosition = 0.5 + edgePull * 0.5;
        }
      }
      
      weightedPosition = THREE.MathUtils.clamp(weightedPosition, 0, 1);
      laneIndex = Math.floor(weightedPosition * numLanes);
    } else {
      laneIndex = Math.floor(random * numLanes);
    }
    
    laneIndex = THREE.MathUtils.clamp(laneIndex, 0, numLanes - 1);
    
    const laneHeight = (Y_DISTANCE * 2) / numLanes;
    const laneCenter = -Y_DISTANCE + (laneIndex + 0.5) * laneHeight;
    
    const variationSeed = seed + 10000;
    const laneVariation = (seededRandom(variationSeed) - 0.5) * laneHeight * DESKTOP_CONFIG.yLaneVariationFactor;
    
    return laneCenter + laneVariation;
  }

  function getDesktopXLaneDistribution(
    index: number,
    repetitionIndex: number,
    baseX: number,
    numLanes: number
  ): number {
    const laneIndex = (index * DESKTOP_CONFIG.xLaneIndexMultiplier + repetitionIndex) % numLanes;
    
    const laneWidth = (DESKTOP_CONFIG.xLaneVariance * 2) / numLanes;
    const laneOffset = -DESKTOP_CONFIG.xLaneVariance + (laneIndex + 0.5) * laneWidth;
    
    const seed = index * DESKTOP_CONFIG.seeds.xLane + repetitionIndex * DESKTOP_CONFIG.seeds.xLaneRepetition;
    const laneVariation = (seededRandom(seed) - 0.5) * laneWidth * DESKTOP_CONFIG.xLaneVariationFactor;
    
    return baseX + laneOffset + laneVariation;
  }

  function getMobileYLaneDistribution(
    index: number,
    totalObjects: number,
    numLanes: number,
    adjustedYDistance: number
  ): number {
    const laneIndex = Math.floor((index * numLanes) / totalObjects);
    
    const startRange = adjustedYDistance * MOBILE_CONFIG.yStartRangeMultiplier;
    const laneHeight = startRange / numLanes;
    const laneCenter = -adjustedYDistance - (laneIndex + 0.5) * laneHeight;
    
    const seed = index * MOBILE_CONFIG.seeds.yLane + MOBILE_CONFIG.seeds.yLaneOffset;
    const laneVariation = (seededRandom(seed) - 0.5) * laneHeight * MOBILE_CONFIG.yLaneVariationFactor;
    
    return laneCenter + laneVariation;
  }

  // Create funnel object (desktop mode)
  function createFunnelObject(
    texture: THREE.Texture,
    geometry: THREE.PlaneGeometry,
    direction: "left-to-right" | "right-to-left",
    index: number,
    totalObjects: number,
    scene: THREE.Scene,
    repetitionIndex: number = 0
  ): FunnelObject {
    const baseX = direction === "left-to-right" ? -X_DISTANCE : X_DISTANCE;
    const x = getDesktopXLaneDistribution(index, repetitionIndex, baseX, DESKTOP_CONFIG.numLanes.x);
    const adjustedIndex = index + (repetitionIndex * totalObjects);
    const y = getDesktopYLaneDistribution(index, repetitionIndex, DESKTOP_CONFIG.numLanes.y);
    const z = direction === "left-to-right"
      ? Z_INDEX_SPACING * adjustedIndex
      : Z_INDEX_SPACING * (adjustedIndex + Z_OFFSET_RIGHT);

    const mesh = createBaseMesh(texture, geometry, { x, y: y + Y_OFFSET, z }, scene);

    const seedMultiplier = direction === "left-to-right"
      ? DESKTOP_CONFIG.seeds.left
      : DESKTOP_CONFIG.seeds.right;
    const offsetSeed = adjustedIndex * seedMultiplier + repetitionIndex * DESKTOP_CONFIG.seeds.repetition;

    return {
      mesh,
      startPosition: { x, y: y + Y_OFFSET, z },
      offset: seededRandom(offsetSeed),
      direction,
    };
  }

  // Create mobile funnel object (bottom-to-top)
  function createMobileFunnelObject(
    texture: THREE.Texture,
    geometry: THREE.PlaneGeometry,
    index: number,
    totalObjects: number,
    scene: THREE.Scene
  ): FunnelObject {
    const laneIndex = index % MOBILE_CONFIG.numLanes.x;

    const laneWidth = (MOBILE_CONFIG.xVariance * 2) / MOBILE_CONFIG.numLanes.x;
    const laneCenter = -MOBILE_CONFIG.xVariance + (laneIndex + 0.5) * laneWidth;
    const xVariation = (seededRandom(index * MOBILE_CONFIG.seeds.xVariation) - 0.5) * laneWidth * MOBILE_CONFIG.xLaneVariationFactor;
    const x = laneCenter + xVariation;

    // Usar altura ajustada para evitar sobreposição com notificações
    const adjustedYDistance = getAdjustedMobileYDistance();

    // Distribuir partículas em faixas Y com quantidades iguais
    const y = getMobileYLaneDistribution(index, totalObjects, MOBILE_CONFIG.numLanes.y, adjustedYDistance);

    const z = Z_INDEX_SPACING * index;

    const mesh = createBaseMesh(texture, geometry, { x, y: y + MOBILE_CONFIG.yOffset, z }, scene);

    return {
      mesh,
      startPosition: { x, y: y + MOBILE_CONFIG.yOffset, z },
      offset: seededRandom(index * MOBILE_CONFIG.seeds.offset),
      direction: "bottom-to-top",
    };
  }

  // Calculate X position based on direction and progress
  function calculateXPosition(
    direction: "left-to-right" | "right-to-left",
    progress: number
  ): number {
    const startX = direction === "left-to-right" ? -X_DISTANCE : X_DISTANCE;
    return THREE.MathUtils.mapLinear(progress, 0, 1, startX, 0);
  }

  // Calculate Y position with convergence and noise
  function calculateYPosition(
    direction: "left-to-right" | "right-to-left",
    x: number,
    startY: number,
    noiseOffset: number
  ): number {
    const startX = direction === "left-to-right" ? -X_DISTANCE : X_DISTANCE;
    const normalizedX = THREE.MathUtils.mapLinear(x, startX, 0, 0, 1);

    // Aplicar transformação parabólica para criar curva de convergência
    const curveY = startY * Math.pow(1 - normalizedX, CURVATURE_FACTOR);

    return curveY + noiseOffset;
  }

  // Calculate scale based on position (desktop)
  function calculateScale(
    direction: "left-to-right" | "right-to-left",
    x: number
  ): number {
    const startX = direction === "left-to-right" ? -X_DISTANCE : X_DISTANCE;
    return THREE.MathUtils.mapLinear(x, startX, 0, 1, MIN_SCALE);
  }

  // Mobile-specific calculation functions
  function calculateMobileYPosition(
    progress: number,
    startY: number
  ): number {
    const adjustedYDistance = getAdjustedMobileYDistance();
    
    return THREE.MathUtils.mapLinear(
      progress,
      0,
      1,
      startY,
      adjustedYDistance
    );
  }

  function calculateMobileScale(y: number): number {
    const adjustedYDistance = getAdjustedMobileYDistance();
    
    const normalizedY = THREE.MathUtils.clamp(
      THREE.MathUtils.mapLinear(
        y,
        -adjustedYDistance,
        adjustedYDistance,
        0,
        1
      ),
      0,
      1
    );
    const easedProgress = 1 - Math.pow(1 - normalizedY, 2);
    return THREE.MathUtils.mapLinear(
      easedProgress,
      0,
      1,
      1,
      MOBILE_CONFIG.scaleMin
    );
  }

  // Type guard to check if object is desktop type
  function isDesktopObject(
    object: FunnelObject
  ): object is FunnelObject & { direction: "left-to-right" | "right-to-left" } {
    return (
      object.direction === "left-to-right" ||
      object.direction === "right-to-left"
    );
  }

  // Type guard to check if object is mobile type
  function isMobileObject(
    object: FunnelObject
  ): object is FunnelObject & { direction: "bottom-to-top" } {
    return object.direction === "bottom-to-top";
  }

  // Update mesh opacity only if changed significantly
  function updateMeshOpacity(object: FunnelObject, opacity: number): void {
    if (
      object.cachedOpacity === undefined ||
      Math.abs(object.cachedOpacity - opacity) > OPACITY_CHANGE_THRESHOLD
    ) {
      (object.mesh.material as THREE.MeshBasicMaterial).opacity = opacity;
      (object.mesh.material as THREE.MeshBasicMaterial).needsUpdate = true;
      object.cachedOpacity = opacity;
    }
  }

  // Calculate noise offset for animation
  function calculateNoiseOffset(
    progress: number,
    index: number,
    scale: number
  ): number {
    const noiseInput = progress * Math.PI * 2;
    return noise(Math.cos(noiseInput) + index, Math.sin(noiseInput)) * scale;
  }

  // Animate individual object (desktop)
  function updateObject(
    object: FunnelObject & { direction: "left-to-right" | "right-to-left" },
    index: number,
    progress: number
  ): void {
    const { mesh, offset, direction, startPosition } = object;
    const uniqueProgress = (progress + offset) % 1;

    const x = calculateXPosition(direction, uniqueProgress);
    const yOffset = calculateNoiseOffset(uniqueProgress, index, DESKTOP_CONFIG.noiseScale);
    const y = calculateYPosition(direction, x, startPosition.y, yOffset);

    const scale = calculateScale(direction, x);
    const opacity = THREE.MathUtils.clamp(
      THREE.MathUtils.mapLinear(Math.abs(x), DESKTOP_CONFIG.opacityFadeStart, 0, 1, MIN_OPACITY),
      MIN_OPACITY,
      1
    );

    updateMeshOpacity(object, opacity);

    mesh.position.x = x;
    mesh.position.y = y + Y_OFFSET;
    mesh.scale.set(scale, scale, 1);
  }

  // Animate individual object (mobile)
  function updateMobileObject(
    object: FunnelObject & { direction: "bottom-to-top" },
    index: number,
    progress: number
  ): void {
    const { mesh, offset, startPosition } = object;
    const uniqueProgress = (progress + offset) % 1;

    const y = calculateMobileYPosition(uniqueProgress, startPosition.y);
    const xOffset = calculateNoiseOffset(uniqueProgress, index, MOBILE_CONFIG.noiseScale);
    
    // Usar altura ajustada para consistência
    const adjustedYDistance = getAdjustedMobileYDistance();
    
    const x = THREE.MathUtils.mapLinear(
      y,
      startPosition.y,
      adjustedYDistance,
      startPosition.x,
      0
    ) + xOffset;

    const scale = calculateMobileScale(y);

    // Curva de opacidade melhorada com fade suave nas extremidades
    const normalizedY = THREE.MathUtils.clamp(
      Math.abs(y) / adjustedYDistance,
      0,
      1
    );
    const fadeStart = MOBILE_CONFIG.opacityFadeStart;

    let opacity: number;
    if (normalizedY < fadeStart) {
      opacity = 1;
    } else {
      // Usar ease-in para fade mais suave
      const fadeProgress = (normalizedY - fadeStart) / (1 - fadeStart);
      opacity = Math.max(
        1 - Math.pow(fadeProgress, MOBILE_CONFIG.fadeEaseExponent),
        MOBILE_CONFIG.minOpacity
      );
    }

    updateMeshOpacity(object, opacity);

    mesh.position.x = x + MOBILE_CONFIG.xOffset;
    mesh.position.y = y + MOBILE_CONFIG.yOffset;
    mesh.scale.set(scale, scale, 1);
  }

  function getCanvasDimensions(canvas: HTMLCanvasElement): {
    width: number;
    height: number;
  } {
    const rect = canvas.getBoundingClientRect();
    let width = rect.width || canvas.clientWidth;
    let height = rect.height || canvas.clientHeight;

    if (width <= 0 || height <= 0) {
      const parent = canvas.parentElement;
      if (parent) {
        const parentRect = parent.getBoundingClientRect();
        width = Math.max(parentRect.width - CANVAS_CONFIG.paddingOffset, CANVAS_CONFIG.minDimension);
        height = Math.max(parentRect.height - CANVAS_CONFIG.paddingOffset, CANVAS_CONFIG.minDimension);
      }
    }

    return {
      width: width || CANVAS_CONFIG.minDimension,
      height: height || CANVAS_CONFIG.minDimension,
    };
  }

  // Main initialization function
  async function initThreeFunnel(canvasId: string) {
    const canvas = document.getElementById(canvasId) as HTMLCanvasElement;
    if (!canvas) return;

    let retries = 0;
    let dimensions = getCanvasDimensions(canvas);

    while (
      (dimensions.width <= CANVAS_CONFIG.minDimension || dimensions.height <= CANVAS_CONFIG.minDimension) &&
      retries < CANVAS_CONFIG.init.maxRetries
    ) {
      await new Promise((resolve) => setTimeout(resolve, CANVAS_CONFIG.init.retryDelayMs));
      dimensions = getCanvasDimensions(canvas);
      retries++;
    }

    const { width, height } = dimensions;

    // Calculate dynamic distances based on viewport size
    const distances = calculateDistances(width, height);
    X_DISTANCE = distances.xDistance;
    Y_DISTANCE = distances.yDistance;

    canvas.width = width;
    canvas.height = height;

    const renderer = new THREE.WebGLRenderer({
      canvas,
      antialias: !isMobile, // Disable antialiasing on mobile for performance
      alpha: true,
    });
    renderer.setSize(width, height);
    // Reduce pixel ratio on mobile for better performance
    renderer.setPixelRatio(
      isMobile ? Math.min(window.devicePixelRatio, MOBILE_CONFIG.maxPixelRatio) : window.devicePixelRatio
    );
    renderer.setClearColor(RENDERER_CONFIG.clearColor, RENDERER_CONFIG.clearAlpha);
    renderer.sortObjects = true;

    const camera = new THREE.PerspectiveCamera(CAMERA_CONFIG.fov, width / height, CAMERA_CONFIG.near, CAMERA_CONFIG.far);
    camera.position.set(0, 0, CAMERA_CONFIG.positionZ);
    camera.lookAt(0, 0, 0);

    const scene = new THREE.Scene();

    const textureLoader = new THREE.TextureLoader();
    const LOOP_DURATION = isMobile ? MOBILE_CONFIG.loopDurationMs : DESKTOP_CONFIG.loopDurationMs;

    interface LoadedTextureData {
      texture: THREE.Texture;
      width: number;
      height: number;
      index: number;
    }

    let objects: FunnelObject[] = [];

    function createGeometry(
      width: number,
      height: number
    ): THREE.PlaneGeometry {
      return new THREE.PlaneGeometry(width, height);
    }

    const loadTexturePromises = textureDefinitions.map(
      (textureDefinition, i) => {
        return new Promise<LoadedTextureData | null>((resolve) => {
          const texture = textureLoader.load(
            textureDefinition.path,
            () => {
              const aspectRatio = texture.image.width / texture.image.height;
              const height = textureDefinition.width / aspectRatio;

              resolve({
                texture,
                width: textureDefinition.width,
                height: height,
                index: i,
              });
            },
            undefined,
            (error: unknown) => {
              console.error(
                `Error loading texture ${i + 1}:`,
                textureDefinition.path,
                error
              );
              resolve(null);
            }
          );
        });
      }
    );

    const loadedTextureData = await Promise.all(loadTexturePromises);
    const validTextureData = loadedTextureData.filter(
      (data): data is NonNullable<typeof data> => data !== null
    );

    // Function to create objects based on current mode
    function createObjectsForMode(mode: "desktop" | "mobile") {
      // Clear existing objects
      objects.forEach((obj) => scene.remove(obj.mesh));
      objects = [];

      const dataToUse =
        mode === "mobile"
          ? validTextureData.slice(0, MOBILE_CONFIG.textureCount)
          : validTextureData;

      for (const { texture, width, height, index: i } of dataToUse) {
        const geometry = createGeometry(width, height);

        if (mode === "desktop") {
          for (let repetition = 0; repetition < DESKTOP_CONFIG.objectsPerTexture; repetition++) {
            const leftObject = createFunnelObject(
              texture,
              geometry,
              "left-to-right",
              i,
              validTextureData.length,
              scene,
              repetition
            );
            objects.push(leftObject);

            const rightObject = createFunnelObject(
              texture,
              geometry.clone(),
              "right-to-left",
              i,
              validTextureData.length,
              scene,
              repetition
            );
            objects.push(rightObject);
          }
        } else {
          const mobileObject = createMobileFunnelObject(
            texture,
            geometry,
            i,
            dataToUse.length,
            scene
          );
          objects.push(mobileObject);
        }
      }
    }

    // Initialize objects for current mode
    createObjectsForMode(isMobile ? "mobile" : "desktop");

    let startTime = Date.now();
    let pausedTime = 0;
    let animationFrameId: number | null = null;
    let isAnimating = false;

    function animate() {
      if (!isAnimating) return;

      const currentTime = Date.now();
      const elapsed = currentTime - startTime - pausedTime;
      const progress = (elapsed / LOOP_DURATION) % 1;

      objects.forEach((object, index) => {
        if (isMobileObject(object)) {
          updateMobileObject(object, index, progress);
        } else if (isDesktopObject(object)) {
          updateObject(object, index, progress);
        }
      });

      renderer.render(scene, camera);
      animationFrameId = requestAnimationFrame(animate);
    }

    function pause() {
      if (isAnimating && animationFrameId !== null) {
        isAnimating = false;
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
        pausedTime = Date.now() - startTime - pausedTime;
      }
    }

    function resume() {
      if (!isAnimating) {
        isAnimating = true;
        startTime = Date.now() - pausedTime;
        animate();
      }
    }

    // ============================================================================
    // DEV GUI SETUP
    // ============================================================================
    if (import.meta.env.DEV && !isMobile) {
      const gui = new GUI({ title: "Desktop Funnel Config", width: 320 });

      // Helper function to update animation with new config
      const updateAnimation = () => {
        // Recalculate distances based on config
        X_DISTANCE = DESKTOP_CONFIG.initial.x;
        Y_DISTANCE = DESKTOP_CONFIG.initial.y;

        // Recreate objects with new config
        createObjectsForMode("desktop");

        // Reset animation timing to see changes immediately
        startTime = Date.now();
        pausedTime = 0;
      };

      // Initial Position folder
      const initialFolder = gui.addFolder("Initial Position");
      initialFolder.add(DESKTOP_CONFIG.initial, "x", 4, 20, 0.5)
        .name("X Distance")
        .onChange(updateAnimation);
      initialFolder.add(DESKTOP_CONFIG.initial, "y", 4, 20, 0.5)
        .name("Y Distance")
        .onChange(updateAnimation);

      // Objects folder
      const objectsFolder = gui.addFolder("Objects");
      objectsFolder.add(DESKTOP_CONFIG, "objectsPerTexture", 1, 10, 1)
        .name("Objects per Texture")
        .onChange(updateAnimation);

      // Lanes folder
      const lanesFolder = gui.addFolder("Lanes");
      lanesFolder.add(DESKTOP_CONFIG.numLanes, "x", 1, 10, 1)
        .name("X Lanes")
        .onChange(updateAnimation);
      lanesFolder.add(DESKTOP_CONFIG.numLanes, "y", 1, 10, 1)
        .name("Y Lanes")
        .onChange(updateAnimation);
      lanesFolder.add(DESKTOP_CONFIG, "xLaneVariance", 0, 3, 0.1)
        .name("X Lane Variance")
        .onChange(updateAnimation);
      lanesFolder.add(DESKTOP_CONFIG, "xLaneIndexMultiplier", 1, 5, 1)
        .name("X Lane Index Mult")
        .onChange(updateAnimation);
      lanesFolder.add(DESKTOP_CONFIG, "yLaneEdgeConcentration", 0, 1, 0.05)
        .name("Y Lane Edge Concentration")
        .onChange(updateAnimation);

      // Variation folder
      const variationFolder = gui.addFolder("Variation");
      variationFolder.add(DESKTOP_CONFIG, "yLaneVariationFactor", 0, 2, 0.1)
        .name("Y Lane Variation")
        .onChange(updateAnimation);
      variationFolder.add(DESKTOP_CONFIG, "xLaneVariationFactor", 0, 2, 0.1)
        .name("X Lane Variation")
        .onChange(updateAnimation);

      // Animation folder
      const animationFolder = gui.addFolder("Animation");
      animationFolder.add(DESKTOP_CONFIG, "noiseScale", 0, 0.01, 0.0001)
        .name("Noise Scale")
        .onChange(updateAnimation);
      animationFolder.add(DESKTOP_CONFIG, "loopDurationMs", 10000, 100000, 1000)
        .name("Loop Duration (ms)")
        .onChange(updateAnimation);
      animationFolder.add(DESKTOP_CONFIG, "opacityFadeStart", 0, 10, 0.5)
        .name("Opacity Fade Start")
        .onChange(updateAnimation);

      // Seeds folder
      const seedsFolder = gui.addFolder("Seeds");
      seedsFolder.add(DESKTOP_CONFIG.seeds, "left", 0, 10000, 1)
        .name("Left")
        .onChange(updateAnimation);
      seedsFolder.add(DESKTOP_CONFIG.seeds, "right", 0, 10000, 1)
        .name("Right")
        .onChange(updateAnimation);
      seedsFolder.add(DESKTOP_CONFIG.seeds, "repetition", 0, 10000, 1)
        .name("Repetition")
        .onChange(updateAnimation);
      seedsFolder.add(DESKTOP_CONFIG.seeds, "yLane", 0, 10000, 1)
        .name("Y Lane")
        .onChange(updateAnimation);
      seedsFolder.add(DESKTOP_CONFIG.seeds, "yLaneRepetition", 0, 10000, 1)
        .name("Y Lane Repetition")
        .onChange(updateAnimation);
      seedsFolder.add(DESKTOP_CONFIG.seeds, "xLane", 0, 10000, 1)
        .name("X Lane")
        .onChange(updateAnimation);
      seedsFolder.add(DESKTOP_CONFIG.seeds, "xLaneRepetition", 0, 10000, 1)
        .name("X Lane Repetition")
        .onChange(updateAnimation);
      seedsFolder.add(DESKTOP_CONFIG.seeds, "uniformLeft", 0, 10000, 1)
        .name("Uniform Left")
        .onChange(updateAnimation);
      seedsFolder.add(DESKTOP_CONFIG.seeds, "uniformRight", 0, 10000, 1)
        .name("Uniform Right")
        .onChange(updateAnimation);

      // Distribution Y folder
      const distributionFolder = gui.addFolder("Distribution Y");
      distributionFolder.add(DESKTOP_CONFIG.distributionY, "gaussianU1", 0, 5000, 100)
        .name("Gaussian U1")
        .onChange(updateAnimation);
      distributionFolder.add(DESKTOP_CONFIG.distributionY, "gaussianU2", 0, 5000, 100)
        .name("Gaussian U2")
        .onChange(updateAnimation);
      distributionFolder.add(DESKTOP_CONFIG.distributionY, "gaussianFactor", 0, 2, 0.1)
        .name("Gaussian Factor")
        .onChange(updateAnimation);
      distributionFolder.add(DESKTOP_CONFIG.distributionY, "layerVariation", 0, 10000, 100)
        .name("Layer Variation")
        .onChange(updateAnimation);
      distributionFolder.add(DESKTOP_CONFIG.distributionY, "layerVariationFactor", 0, 1, 0.05)
        .name("Layer Var Factor")
        .onChange(updateAnimation);
      distributionFolder.add(DESKTOP_CONFIG.distributionY, "spiralTurns", 0, 10, 0.5)
        .name("Spiral Turns")
        .onChange(updateAnimation);

      // Close all folders by default for cleaner UI
      initialFolder.close();
      objectsFolder.close();
      lanesFolder.close();
      variationFolder.close();
      animationFolder.close();
      seedsFolder.close();
      distributionFolder.close();

      // Add reset button
      gui.add({
        reset: () => {
          // Reset all values to defaults
          Object.assign(DESKTOP_CONFIG, JSON.parse(JSON.stringify(DEFAULT_DESKTOP_CONFIG)));
          gui.destroy();
          // Reinitialize GUI with reset values
          location.reload();
        }
      }, "reset").name("Reset to Defaults");
    }

    // IntersectionObserver to pause/resume animation when canvas is not visible
    const intersectionObserver = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            resume();
          } else {
            pause();
          }
        });
      },
      { threshold: OBSERVER_CONFIG.intersectionThreshold }
    );

    intersectionObserver.observe(canvas);

    // Page Visibility API to pause/resume when user switches tabs
    const handleVisibilityChange = () => {
      if (document.hidden) {
        pause();
      } else {
        // Check if canvas is in viewport before resuming
        const rect = canvas.getBoundingClientRect();
        const isInViewport =
          rect.top < window.innerHeight && rect.bottom > 0;
        if (isInViewport) {
          resume();
        }
      }
    };

    document.addEventListener("visibilitychange", handleVisibilityChange);

    // Start animation initially only if canvas is visible
    const rect = canvas.getBoundingClientRect();
    const isInitiallyVisible = rect.top < window.innerHeight && rect.bottom > 0;
    if (isInitiallyVisible) {
      isAnimating = true;
      animate();
    }

    let currentWidth = width;
    let currentHeight = height;
    let previousXDistance = X_DISTANCE;
    let previousYDistance = Y_DISTANCE;

    function onWindowResize() {
      const clientWidth = window.innerWidth;
      const clientHeight = window.innerHeight;

      // Early return if dimensions unchanged
      if (clientWidth === currentWidth && clientHeight === currentHeight) return;
      if (clientWidth <= 0 || clientHeight <= 0) return;

      // Check mode change
      const newIsMobile = clientWidth <= MOBILE_BREAKPOINT;
      const modeChanged = newIsMobile !== isMobile;
      if (modeChanged) isMobile = newIsMobile;

      // Check distances change for desktop mode
      const distancesChanged = !isMobile && (() => {
        const newDistances = calculateDistances(clientWidth, clientHeight);

        const xChanged = Math.abs(newDistances.xDistance - previousXDistance) / previousXDistance > OBSERVER_CONFIG.distanceChangeThreshold;
        const yChanged = Math.abs(newDistances.yDistance - previousYDistance) / previousYDistance > OBSERVER_CONFIG.distanceChangeThreshold;

        if (xChanged || yChanged) {
          X_DISTANCE = newDistances.xDistance;
          Y_DISTANCE = newDistances.yDistance;
          previousXDistance = X_DISTANCE;
          previousYDistance = Y_DISTANCE;
          return true;
        }
        return false;
      })();

      // Recreate objects if needed
      if (modeChanged || distancesChanged) {
        createObjectsForMode(isMobile ? "mobile" : "desktop");
      }

      // Update dimensions and camera
      currentWidth = clientWidth;
      currentHeight = clientHeight;
      camera.aspect = clientWidth / clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(clientWidth, clientHeight);
      renderer.setPixelRatio(
        isMobile ? Math.min(window.devicePixelRatio, MOBILE_CONFIG.maxPixelRatio) : window.devicePixelRatio
      );
    }

    // Debounce resize handler to avoid excessive calls
    let resizeTimeout: number | null = null;
    function debouncedResize() {
      if (resizeTimeout !== null) {
        clearTimeout(resizeTimeout);
      }
      resizeTimeout = window.setTimeout(() => {
        onWindowResize();
        resizeTimeout = null;
      }, OBSERVER_CONFIG.resizeDebounceMs);
    }

    if (typeof ResizeObserver !== "undefined") {
      const resizeObserver = new ResizeObserver(() => {
        debouncedResize();
      });
      resizeObserver.observe(canvas);
    }

    window.addEventListener("resize", debouncedResize);

    window.addEventListener("orientationchange", () => {
      setTimeout(onWindowResize, OBSERVER_CONFIG.orientationChangeDelayMs);
    });

    return () => {
      pause();
      if (resizeTimeout !== null) {
        clearTimeout(resizeTimeout);
      }
      intersectionObserver.disconnect();
      document.removeEventListener("visibilitychange", handleVisibilityChange);
      window.removeEventListener("resize", debouncedResize);
      window.removeEventListener("orientationchange", onWindowResize);
      renderer.dispose();
      scene.clear();
    };
  }

  // Initialize all funnel canvases when page loads
  function initAllFunnels() {
    const canvases = document.querySelectorAll('[data-funnel-id]');
    canvases.forEach((canvas) => {
      // Only initialize visible canvases (check if not hidden by CSS)
      const isVisible = (canvas as HTMLElement).offsetParent !== null;

      if (isVisible) {
        const canvasId = canvas.getAttribute('data-funnel-id');
        if (canvasId) {
          initThreeFunnel(canvasId);
        }
      }
    });
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initAllFunnels);
  } else {
    initAllFunnels();
  }
</script>
