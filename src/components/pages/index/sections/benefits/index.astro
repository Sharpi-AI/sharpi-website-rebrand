---
import RecommendationCard from "./recommendation.astro";
import FollowUpCard from "./follow-up.astro";
import NotificationsCard from "./notifications.astro";
import ReactivationCard from "./reactivation.astro";
---

<section id="benefits" class="py-28 px-2.5 w-full flex flex-col items-center justify-center overflow-hidden">
  <h2
    class="text-[37px] md:text-[58px] max-w-[18ch] text-center font-normal leading-none text-[#383838] mb-5 md:mb-14 tracking-tight"
  >
    Nossa IA vende com você e para você.
  </h2>
  <p class="text-sm text-center  tracking-[-0.02em] leading-snug text-[#3D3939] mb-10 md:hidden">A IA da Sharpi envia orçamentos 24/7, liberando seu time para focar em relacionamentos que impulsionam o crescimento.</p>

  <div class="carousel-container max-w-7xl w-full">
    <div class="carousel-track" id="benefits-carousel">
      <div class="carousel-slide">
        <div class="shining-border">
          <RecommendationCard/>
        </div>
      </div>
      <div class="carousel-slide">
        <div class="shining-border">
          <ReactivationCard/>
        </div>
      </div>
      <div class="carousel-slide">
        <div class="shining-border">
          <NotificationsCard/>
        </div>
      </div>
      <div class="carousel-slide">
        <div class="shining-border">
          <FollowUpCard/>
        </div>
      </div>
    </div>
  </div>
</section>

<style is:global>
  .carousel-container {
    width: 100%;
    position: relative;
  }

  .carousel-track {
    display: flex;
    gap: 20px;
    overflow-x: visible;
    cursor: grab;
    user-select: none;
    will-change: transform;
    transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  }

  .carousel-track.is-dragging {
    cursor: grabbing;
    transition: none;
  }

  .carousel-track.is-snapping {
    transition: transform 0.35s cubic-bezier(0.25, 0.1, 0.25, 1);
  }

  .carousel-slide {
    flex: 0 0 auto;
  }

  @media (max-width: 640px) {
    .carousel-track {
      gap: 16px;
    }
  }

  .shining-border {
    padding: 2px;
    position: relative;
    overflow: hidden;
    border-radius: 21px;
    transition: all 0.3s ease;
    isolation: isolate;
    contain: layout style paint;
  }

  .carousel-slide.is-active .shining-border::before {
    content: "";
    position: absolute;
    z-index: -2;
    left: -50%;
    top: -50%;
    width: 180%;
    height: 180%;
    background-color: #000;
    background-repeat: no-repeat;
    background-size: 100% 100%, 50% 50%;
    background-position: 0 0, 100% 0, 100% 100%, 0 100%;
    background-image:  linear-gradient(180deg, #3609FF 0%, #F1F1F1 23.56%, #CFD9FF 44.23%, #7EADFF 100%);
    animation: bgRotate 4s linear infinite;
    backface-visibility: hidden;
    -webkit-backface-visibility: hidden;
    will-change: transform;
  }

  .carousel-slide.is-active .shining-border::after {
    content: "";
    position: absolute;
    z-index: -1;
    left: 2px;
    top: 2px;
    width: calc(100% - 4px);
    height: calc(100% - 4px);
    background: #F0F0F0;
    border-radius: 20px;
    transform: translateZ(0);
    backface-visibility: hidden;
    -webkit-backface-visibility: hidden;
  }

  @keyframes bgRotate {
    0% {
      transform: translateZ(0) rotate(0deg);
    }
    100% {
      transform: translateZ(0) rotate(360deg);
    }
  }

  .carousel-slide.is-active #follow-up-text {
  max-height: 2rem !important;
  opacity: 1;
}

.carousel-slide.is-active #follow-up-device {
  transform: translateY(-20px);
}


.carousel-slide.is-active #follow-up-card {
  transform: translateY(-20px);
}
</style>

<script>
  const initCarousel = () => {
    const carousel = document.getElementById('benefits-carousel');
    if (!carousel) return;

    const slides = carousel.querySelectorAll('.carousel-slide');
    const container = carousel.parentElement;
    if (!container) return;

    let currentX = 0;
    let targetX = 0;
    let isDragging = false;
    let hasMoved = false;
    let startX = 0;
    let startTranslateX = 0;
    let velocity = 0;
    let lastX = 0;
    let lastTime = Date.now();
    let rafId = null;
    let snapTimeout = null;

    // Calculate bounds (desktop: show multiple cards, mobile: allow last slide to reach left edge)
    const getBounds = () => {
      if (slides.length === 0) return { min: 0, max: 0 };

      const isDesktop = window.innerWidth > 768;
      const containerRect = container.getBoundingClientRect();
      const carouselRect = carousel.getBoundingClientRect();

      if (isDesktop) {
        // Desktop: limit scroll to when content width exceeds container width
        const containerWidth = containerRect.width;
        const carouselWidth = carousel.scrollWidth;
        const maxScroll = carouselWidth - containerWidth;

        // Only allow scroll if content is wider than container
        if (maxScroll > 0) {
          return {
            min: -maxScroll,
            max: 0
          };
        }

        // Content fits in container, no scroll needed
        return { min: 0, max: 0 };
      }

      // Mobile: allow last slide to reach left edge
      const lastSlide = slides[slides.length - 1];
      const lastSlideRect = lastSlide.getBoundingClientRect();
      const lastSlideOffset = lastSlideRect.left - carouselRect.left;

      return {
        min: -Math.abs(lastSlideOffset),
        max: 0
      };
    };

    // Get closest slide index (based on left edge)
    const getClosestSlideIndex = () => {
      let closestIndex = 0;
      let closestDistance = Number.POSITIVE_INFINITY;

      for (let i = 0; i < slides.length; i++) {
        const slide = slides[i];
        const rect = slide.getBoundingClientRect();
        const containerRect = container.getBoundingClientRect();
        const slideLeft = rect.left - containerRect.left;
        const distance = Math.abs(slideLeft);

        if (distance < closestDistance) {
          closestDistance = distance;
          closestIndex = i;
        }
      }

      return closestIndex;
    };

    // Update active slide
    const updateActiveSlide = () => {
      const closestIndex = getClosestSlideIndex();
      for (let i = 0; i < slides.length; i++) {
        if (i === closestIndex) {
          slides[i].classList.add('is-active');
        } else {
          slides[i].classList.remove('is-active');
        }
      }
    };

    // Apply transform
    const applyTransform = (x) => {
      const bounds = getBounds();
      const clampedX = Math.max(bounds.min, Math.min(bounds.max, x));
      carousel.style.transform = `translateX(${clampedX}px)`;
      currentX = clampedX;
      updateActiveSlide();
    };

    // Snap to specific slide by index
    const snapToSlide = (index: number) => {
      if (index < 0 || index >= slides.length) return;

      carousel.classList.add('is-snapping');
      const slide = slides[index];
      const containerRect = container.getBoundingClientRect();
      const slideRect = slide.getBoundingClientRect();
      const containerLeft = containerRect.left;
      const slideLeft = slideRect.left;
      const offset = containerLeft - slideLeft;

      targetX = currentX + offset;
      const bounds = getBounds();
      targetX = Math.max(bounds.min, Math.min(bounds.max, targetX));

      applyTransform(targetX);

      setTimeout(() => {
        carousel.classList.remove('is-snapping');
      }, 350);
    };

    // Snap to closest slide (align to left edge)
    const snapToClosest = () => {
      const closestIndex = getClosestSlideIndex();
      snapToSlide(closestIndex);
    };

    // Momentum animation
    const animate = () => {
      if (!isDragging && Math.abs(velocity) > 0.3) {
        velocity *= 0.92; // Friction
        targetX += velocity;
        applyTransform(targetX);
        rafId = requestAnimationFrame(animate);
      } else if (!isDragging) {
        velocity = 0;
        if (rafId) {
          cancelAnimationFrame(rafId);
          rafId = null;
        }

        if (snapTimeout) {
          clearTimeout(snapTimeout);
        }
        snapTimeout = setTimeout(snapToClosest, 50);
      }
    };

    // Mouse/Touch drag handlers
    const handleDragStart = (e: MouseEvent | TouchEvent) => {
      isDragging = true;
      hasMoved = false;
      carousel.classList.add('is-dragging');

      const clientX = e.type.includes('mouse') ? (e as MouseEvent).clientX : (e as TouchEvent).touches[0].clientX;
      startX = clientX;
      startTranslateX = currentX;
      lastX = clientX;
      lastTime = Date.now();
      velocity = 0;

      if (rafId) {
        cancelAnimationFrame(rafId);
        rafId = null;
      }
      if (snapTimeout) {
        clearTimeout(snapTimeout);
        snapTimeout = null;
      }
    };

    const handleDragMove = (e: MouseEvent | TouchEvent) => {
      if (!isDragging) return;

      e.preventDefault();
      const clientX = e.type.includes('mouse') ? (e as MouseEvent).clientX : (e as TouchEvent).touches[0].clientX;
      const deltaX = clientX - startX;

      // Mark as moved if dragged more than 5px
      if (Math.abs(deltaX) > 5) {
        hasMoved = true;
      }

      targetX = startTranslateX + deltaX;

      // Calculate velocity
      const now = Date.now();
      const deltaTime = now - lastTime;
      if (deltaTime > 0) {
        velocity = (clientX - lastX) / deltaTime * 16; // Normalize to 60fps
      }
      lastX = clientX;
      lastTime = now;

      applyTransform(targetX);
    };

    const handleDragEnd = () => {
      if (!isDragging) return;

      isDragging = false;
      carousel.classList.remove('is-dragging');

      // Apply momentum
      if (Math.abs(velocity) > 1.5) {
        rafId = requestAnimationFrame(animate);
      } else {
        snapToClosest();
      }
    };

    // Mouse events
    carousel.addEventListener('mousedown', handleDragStart);
    document.addEventListener('mousemove', handleDragMove);
    document.addEventListener('mouseup', handleDragEnd);

    // Touch events
    carousel.addEventListener('touchstart', handleDragStart, { passive: true });
    carousel.addEventListener('touchmove', handleDragMove, { passive: false });
    carousel.addEventListener('touchend', handleDragEnd);

    // Wheel event (horizontal scroll only)
    carousel.addEventListener('wheel', (e) => {
      // Only handle horizontal scroll, let vertical scroll pass through
      if (Math.abs(e.deltaX) > Math.abs(e.deltaY)) {
        e.preventDefault();

        if (snapTimeout) {
          clearTimeout(snapTimeout);
        }

        targetX -= e.deltaX;
        applyTransform(targetX);

        snapTimeout = setTimeout(snapToClosest, 100);
      }
    }, { passive: false });

    // Click handlers for slides (desktop only)
    slides.forEach((slide, index) => {
      slide.addEventListener('click', (e) => {
        const isDesktop = window.innerWidth > 768;

        // Only handle clicks on desktop and if user didn't drag
        if (!isDesktop || hasMoved) return;

        // Prevent click if currently dragging
        if (isDragging) return;

        snapToSlide(index);
      });
    });

    // Initialize
    applyTransform(0);
    slides[0]?.classList.add('is-active');
  };

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initCarousel);
  } else {
    initCarousel();
  }
</script>