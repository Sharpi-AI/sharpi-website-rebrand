---

---

<div id="orbit-system-container" class="absolute inset-0">
  <canvas
    id="orbit-canvas"
    class="absolute inset-0 w-full h-full"
    style="z-index: 1;"
    aria-hidden="true"
  ></canvas>
  <canvas
    id="blob-canvas"
    class="absolute inset-0 w-full h-full"
    style="z-index: 3;"
    aria-hidden="true"
  ></canvas>
  <div id="orbit-texts-container" class="absolute inset-0 pointer-events-none" style="z-index: 2;">
  </div>
  <div
    id="cloned-cards-container"
    class="absolute left-1/2 -translate-x-1/2 md:left-1/6 top-1/2 -translate-y-1/2 hidden md:flex flex-col gap-16 opacity-0 transition-opacity duration-500 pointer-events-none z-10"
  >
    <p
      class="text-sm text-[#4C43FC] font-normal leading-none max-w-[20ch]"
      aria-hidden="true"
    >
      Substitua todas essas ferramentas de uma sÃ³ vez
    </p>

    <div class="flex flex-col gap-3">
      <div
        class="cloned-card bg-white rounded-xl p-4 pl-3 flex items-center gap-3 shadow-[0_0_12px_0_rgba(0,0,0,0.08)] opacity-0 translate-y-20 scale-75 transition-all duration-400 ease-out w-[173px] max-w-[300px]"
        style="transition-delay: 0ms; transform-origin: left center;"
      >
        <div
          class="flex-shrink-0 size-9 flex items-center justify-center rounded-md"
        >
          <svg
            width="25"
            height="25"
            viewBox="0 0 25 25"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
            ><path
              d="M12.5 8.36133C17.4706 8.36133 21.5 7.01818 21.5 5.36133C21.5 3.70447 17.4706 2.36133 12.5 2.36133C7.52944 2.36133 3.5 3.70447 3.5 5.36133C3.5 7.01818 7.52944 8.36133 12.5 8.36133Z"
              stroke="#4C43FC"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"></path><path
              d="M3.5 5.36133V19.3613C3.5 20.157 4.44821 20.92 6.13604 21.4826C7.82387 22.0453 10.1131 22.3613 12.5 22.3613C14.8869 22.3613 17.1761 22.0453 18.864 21.4826C20.5518 20.92 21.5 20.157 21.5 19.3613V5.36133"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke="#4C43FC"></path><path
              d="M3.5 12.3613C3.5 13.157 4.44821 13.92 6.13604 14.4826C7.82387 15.0453 10.1131 15.3613 12.5 15.3613C14.8869 15.3613 17.1761 15.0453 18.864 14.4826C20.5518 13.92 21.5 13.157 21.5 12.3613"
              stroke="#4C43FC"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"></path></svg
          >
        </div>
        <div class="flex flex-col gap-px">
          <div
            class="text-[15px] text-[#4C43FC] font-medium leading-none tracking-[-0.02em]"
            aria-label="CRM"
          >
            CRM
          </div>
        </div>
      </div>

      <div
        class="cloned-card bg-white rounded-xl p-4 pl-3 flex items-center gap-3 shadow-[0_0_12px_0_rgba(0,0,0,0.08)] opacity-0 translate-y-20 scale-75 transition-all duration-400 ease-out w-fit max-w-[300px]"
        style="transition-delay: 100ms; transform-origin: left center;"
      >
        <div
          class="flex-shrink-0 size-9 flex items-center justify-center rounded-md"
        >
          <svg
            width="23"
            height="23"
            viewBox="0 0 23 23"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
            ><path
              d="M2.49169 15.703C2.63873 16.0739 2.67147 16.4804 2.58569 16.87L1.52069 20.16C1.48638 20.3269 1.49525 20.4997 1.54647 20.6622C1.59769 20.8246 1.68955 20.9713 1.81336 21.0883C1.93716 21.2053 2.0888 21.2887 2.25389 21.3307C2.41898 21.3726 2.59205 21.3717 2.75669 21.328L6.16969 20.33C6.53741 20.2571 6.91822 20.289 7.26869 20.422C9.40408 21.4192 11.8231 21.6302 14.0988 21.0177C16.3746 20.4053 18.361 19.0087 19.7074 17.0744C21.0538 15.1401 21.6738 12.7924 21.458 10.4456C21.2422 8.09871 20.2044 5.90349 18.5278 4.24722C16.8511 2.59094 14.6434 1.58006 12.2941 1.39292C9.94475 1.20578 7.60483 1.8544 5.68713 3.22436C3.76944 4.59432 2.39722 6.59756 1.81258 8.88066C1.22795 11.1638 1.46846 13.58 2.49169 15.703Z"
              stroke="#4C43FC"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"></path></svg
          >
        </div>
        <div class="flex flex-col gap-px">
          <div
            class="text-[15px] text-[#4C43FC] font-medium leading-none tracking-[-0.02em]"
            aria-label="Plataforma de atendimento no WhatsApp"
          >
            Plataforma de atendimento
          </div>
          <div
            class="text-[15px] text-[#6F6F6F] font-mono font-medium leading-none tracking-[-0.02em]"
            aria-hidden="true"
          >
            no WhatsApp
          </div>
        </div>
      </div>

      <div
        class="cloned-card bg-white rounded-xl p-4 pl-3 flex items-center gap-3 shadow-[0_0_12px_0_rgba(0,0,0,0.08)] opacity-0 translate-y-20 scale-75 transition-all duration-400 ease-out w-[200px] max-w-[300px]"
        style="transition-delay: 200ms; transform-origin: left center;"
      >
        <div
          class="flex-shrink-0 size-9 flex items-center justify-center rounded-md"
        >
          <svg
            width="29"
            height="29"
            viewBox="0 0 29 29"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
            ><path
              d="M20.3333 2.69434H8.66659C7.37792 2.69434 6.33325 3.739 6.33325 5.02767V23.6943C6.33325 24.983 7.37792 26.0277 8.66659 26.0277H20.3333C21.6219 26.0277 22.6666 24.983 22.6666 23.6943V5.02767C22.6666 3.739 21.6219 2.69434 20.3333 2.69434Z"
              stroke="#4C43FC"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"></path><path
              d="M14.5 21.3613H14.5117"
              stroke="black"
              stroke-width="2.33333"
              stroke-linecap="round"
              stroke-linejoin="round"></path></svg
          >
        </div>
        <div class="flex flex-col gap-px">
          <div
            class="text-[15px] text-[#4C43FC] font-medium leading-none tracking-[-0.02em]"
            aria-label="App de forÃ§a de Vendas"
          >
            App de forÃ§a
          </div>
          <div
            class="text-[15px] text-[#6F6F6F] font-mono font-medium leading-none tracking-[-0.02em]"
            aria-hidden="true"
          >
            de Vendas
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  import * as THREE from "three";

  import { LensParticleSystem } from "./utils/lens-particle-system";
  import { OrbitingSpheres } from "./utils/orbiting-spheres";
  import { DEFAULT_SETTINGS } from "./utils/config";
  import type { AnimationStage } from "./utils/lens-particle-system";

  type AnimationState = 'idle' | 'entering' | 'active' | 'leaving' | 'paused';

  let currentAnimationState: AnimationState = 'idle';
  let animationFrameId: number | null = null;
  let isInViewport = false;

  const initOrbitSystem = () => {
    const container = document.getElementById(
      "orbit-system-container"
    ) as HTMLElement;
    const orbitCanvas = document.getElementById(
      "orbit-canvas"
    ) as HTMLCanvasElement;
    const blobCanvas = document.getElementById(
      "blob-canvas"
    ) as HTMLCanvasElement;

    if (!container || !orbitCanvas || !blobCanvas) return;

    const width = container.clientWidth;
    const height = container.clientHeight;
    const pixelRatio = Math.min(window.devicePixelRatio, 2);

    // Renderer for orbiting spheres (background layer)
    const orbitRenderer = new THREE.WebGLRenderer({
      canvas: orbitCanvas,
      antialias: true,
      alpha: true,
    });
    orbitRenderer.setSize(width, height);
    orbitRenderer.setPixelRatio(pixelRatio);
    orbitRenderer.setClearColor(0x000000, 0);
    orbitRenderer.toneMapping = THREE.NoToneMapping;
    orbitRenderer.toneMappingExposure = 1.0;

    // Renderer for blob/lens particle system (foreground layer)
    const blobRenderer = new THREE.WebGLRenderer({
      canvas: blobCanvas,
      antialias: true,
      alpha: true,
    });
    blobRenderer.setSize(width, height);
    blobRenderer.setPixelRatio(pixelRatio);
    blobRenderer.setClearColor(0x000000, 0);
    blobRenderer.toneMapping = THREE.NoToneMapping;
    blobRenderer.toneMappingExposure = 1.0;

    const referenceHeight = 604;
    const referenceFOV = 50;

    const vFOV =
      (2 *
        Math.atan(
          Math.tan((referenceFOV * Math.PI) / 360) * (referenceHeight / height)
        ) *
        180) /
      Math.PI;
    const cameraZAdjustment = 8 * (height / referenceHeight);

    const camera = new THREE.PerspectiveCamera(vFOV, width / height, 0.1, 1000);
    camera.position.set(0, 0, cameraZAdjustment);
    camera.lookAt(0, 0, 0);

    // Separate scenes for layering
    const orbitScene = new THREE.Scene();
    const blobScene = new THREE.Scene();

    const animatedParticleSystem = new LensParticleSystem({
      stage1Duration: 3,
      stage2Duration: 3,
      stage3Duration: 3,
      stage4Duration: 3,
      stage1Scale: 0.7,
      stage2Scale: 1.1,
      stage3Scale: 1.4,
      stage4Scale: 1.7,
      finalScale: 1.7,
      initialScale: 0.7,
      returnDelay: 3000,
      returnDuration: 1.2,
      autoLoop: true,

      lensCursorSize: DEFAULT_SETTINGS.lensCursorSize,
      lensCursorIor: DEFAULT_SETTINGS.lensCursorIor,
      lensCursorThickness: DEFAULT_SETTINGS.lensCursorThickness,
      lensCursorChromaticAberration:
        DEFAULT_SETTINGS.lensCursorChromaticAberration,
      lensCursorAnisotropy: DEFAULT_SETTINGS.lensCursorAnisotropy,
      lensCursorTransmission: DEFAULT_SETTINGS.lensCursorTransmission,
      lensCursorRoughness: DEFAULT_SETTINGS.lensCursorRoughness,
      lensCursorDistortion: DEFAULT_SETTINGS.lensCursorDistortion,
      lensCursorDistortionScale: DEFAULT_SETTINGS.lensCursorDistortionScale,
      lensCursorTemporalDistortion:
        DEFAULT_SETTINGS.lensCursorTemporalDistortion,
      lensCursorSamples: 4,
      lensCursorBackside: false,
      lensCursorBacksideThickness: DEFAULT_SETTINGS.lensCursorBacksideThickness,
      lensCursorTransmissionSampler:
        DEFAULT_SETTINGS.lensCursorTransmissionSampler,
      lensCursorResolution: 2024,
      lensCursorBacksideResolution:
        DEFAULT_SETTINGS.lensCursorBacksideResolution,
      lensCursorBackground: "#CCE4F3",
      lensCursorBackgroundScale: 0.2,

      pulseEnabled: true,
      pulseMinScale: 0.98,
      pulseMaxScale: 1.02,
      pulseSpeed: 0.0005,

      smoothingFactor: 2.5,

      useGlobalTiming: true,

      particleSettings: DEFAULT_SETTINGS,

      onStageChange: () => {},
    });

    blobScene.add(animatedParticleSystem.getGroup());

    const orbitingTextItems1 = [
      {
        text1: "CRM",
        icon: '<svg width="25" height="25" viewBox="0 0 25 25" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12.5 8.36133C17.4706 8.36133 21.5 7.01818 21.5 5.36133C21.5 3.70447 17.4706 2.36133 12.5 2.36133C7.52944 2.36133 3.5 3.70447 3.5 5.36133C3.5 7.01818 7.52944 8.36133 12.5 8.36133Z" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M3.5 5.36133V19.3613C3.5 20.157 4.44821 20.92 6.13604 21.4826C7.82387 22.0453 10.1131 22.3613 12.5 22.3613C14.8869 22.3613 17.1761 22.0453 18.864 21.4826C20.5518 20.92 21.5 20.157 21.5 19.3613V5.36133" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M3.5 12.3613C3.5 13.157 4.44821 13.92 6.13604 14.4826C7.82387 15.0453 10.1131 15.3613 12.5 15.3613C14.8869 15.3613 17.1761 15.0453 18.864 14.4826C20.5518 13.92 21.5 13.157 21.5 12.3613" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>',
      },
    ];

    const orbitingTextItems2 = [
      {
        text1: "Plataforma de atendimento",
        text2: "no WhatsApp",
        icon: '<svg width="23" height="23" viewBox="0 0 23 23" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2.49169 15.703C2.63873 16.0739 2.67147 16.4804 2.58569 16.87L1.52069 20.16C1.48638 20.3269 1.49525 20.4997 1.54647 20.6622C1.59769 20.8246 1.68955 20.9713 1.81336 21.0883C1.93716 21.2053 2.0888 21.2887 2.25389 21.3307C2.41898 21.3726 2.59205 21.3717 2.75669 21.328L6.16969 20.33C6.53741 20.2571 6.91822 20.289 7.26869 20.422C9.40408 21.4192 11.8231 21.6302 14.0988 21.0177C16.3746 20.4053 18.361 19.0087 19.7074 17.0744C21.0538 15.1401 21.6738 12.7924 21.458 10.4456C21.2422 8.09871 20.2044 5.90349 18.5278 4.24722C16.8511 2.59094 14.6434 1.58006 12.2941 1.39292C9.94475 1.20578 7.60483 1.8544 5.68713 3.22436C3.76944 4.59432 2.39722 6.59756 1.81258 8.88066C1.22795 11.1638 1.46846 13.58 2.49169 15.703Z" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>',
      },
      {
        text1: "App de forÃ§a",
        text2: "de Vendas",
        icon: '<svg width="29" height="29" viewBox="0 0 29 29" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M20.3333 2.69434H8.66659C7.37792 2.69434 6.33325 3.739 6.33325 5.02767V23.6943C6.33325 24.983 7.37792 26.0277 8.66659 26.0277H20.3333C21.6219 26.0277 22.6666 24.983 22.6666 23.6943V5.02767C22.6666 3.739 21.6219 2.69434 20.3333 2.69434Z" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M14.5 21.3613H14.5117" stroke="black" stroke-width="2.33333" stroke-linecap="round" stroke-linejoin="round"/></svg>',
      },
    ];

    const orbit1Config: any = {
      sphereCount: 300,
      initialRadius: 3.6,
      sphereSize: 0.01,
      // rotationSpeed: 0,
      rotationSpeed: 0.05,
      rotationOffset: 0.55 * Math.PI,
      color: DEFAULT_SETTINGS.particleColor,
      enabled: true,
      isAnimating: true,

      // Essential text props
      textItems: orbitingTextItems1,
      showTexts: true,
      textOffset: 0,
      // textOrbitRadius: 3.6,

      // Animation stages (synchronized with global timing)
      stage1Duration: 3,
      stage2Duration: 3,
      stage3Duration: 3,
      stage4Duration: 3,
      stage1Radius: 3.6,
      stage2Radius: 3.2,
      stage3Radius: 2.5,
      stage4Radius: 1.6,
      finalRadius: 1.6,
      autoLoop: true,
      returnDelay: 3000,
      returnDuration: 1.2,

      // Text fade configuration
      hideTextsByStage: { 0: "stage4" },
      textFadeInDuration: 0.2,
      textFadeOutDuration: 0.3,

      onStageChange: () => {},
    };

    const orbit1 = new OrbitingSpheres(orbit1Config);

    const orbit2Config: any = {
      sphereCount: 220,
      initialRadius: 2.2,
      sphereSize: 0.01,
      
      rotationSpeed: 0.05,
      // rotationSpeed: 0,
      rotationOffset: 0.4 * Math.PI,
      color: DEFAULT_SETTINGS.particleColor,
      enabled: true,
      isAnimating: true,

      // Essential text props
      textItems: orbitingTextItems2,
      showTexts: true,
      textOffset: 0,
      // textOrbitRadius: 2.2,

      // Animation stages (synchronized with global timing)
      stage1Duration: 3,
      stage2Duration: 3,
      stage3Duration: 3,
      stage4Duration: 3,
      stage1Radius: 2.2,
      stage2Radius: 1.8,
      stage3Radius: 1.3,
      stage4Radius: 1,
      finalRadius: 1,
      autoLoop: true,
      returnDelay: 3000,
      returnDuration: 1.2,

      // Text fade configuration - different stages for each text
      hideTextsByStage: { 0: "stage2", 1: "stage3" },
      textFadeInDuration: 0.2,
      textFadeOutDuration: 0.3,

      onStageChange: () => {},
    };

    const orbit2 = new OrbitingSpheres(orbit2Config);

    // Add orbits to orbit scene (background layer)
    orbitScene.add(orbit1.getGroup());
    orbitScene.add(orbit2.getGroup());

    // Set camera reference for text positioning
    orbit1.setCamera(camera);
    orbit2.setCamera(camera);

    // Global animation timing system
    let globalAnimationStartTime = 0;
    let isGlobalAnimationRunning = false;

    // Animation configuration (updated to match AnimatedParticleSystem)
    const ANIMATION_CONFIG = {
      stage1Duration: 3,
      stage2Duration: 3,
      stage3Duration: 3,
      stage4Duration: 3,
      returnDelay: 3000, // in milliseconds
      returnDuration: 1.2,
      autoLoop: true,
    };

    // Calculate total cycle time
    const STAGE_CYCLE_TIME =
      ANIMATION_CONFIG.stage1Duration +
      ANIMATION_CONFIG.stage2Duration +
      ANIMATION_CONFIG.stage3Duration +
      ANIMATION_CONFIG.stage4Duration;

    const TOTAL_CYCLE_TIME =
      STAGE_CYCLE_TIME +
      ANIMATION_CONFIG.returnDelay / 1000 +
      ANIMATION_CONFIG.returnDuration;

    function getCurrentGlobalStage(globalElapsed: number): AnimationStage {
      if (!isGlobalAnimationRunning) return "idle";

      // If autoLoop is disabled, lock at stage4 after completing all stages
      if (!ANIMATION_CONFIG.autoLoop && globalElapsed >= STAGE_CYCLE_TIME) {
        return "stage4";
      }

      // Handle looping
      const cycleElapsed = ANIMATION_CONFIG.autoLoop
        ? globalElapsed % TOTAL_CYCLE_TIME
        : globalElapsed;

      if (cycleElapsed < ANIMATION_CONFIG.stage1Duration) {
        return "stage1";
      } else if (
        cycleElapsed <
        ANIMATION_CONFIG.stage1Duration + ANIMATION_CONFIG.stage2Duration
      ) {
        return "stage2";
      } else if (
        cycleElapsed <
        ANIMATION_CONFIG.stage1Duration +
          ANIMATION_CONFIG.stage2Duration +
          ANIMATION_CONFIG.stage3Duration
      ) {
        return "stage3";
      } else if (cycleElapsed < STAGE_CYCLE_TIME) {
        return "stage4";
      } else if (
        cycleElapsed <
        STAGE_CYCLE_TIME + ANIMATION_CONFIG.returnDelay / 1000
      ) {
        return "completed";
      } else {
        return "returning";
      }
    }

    // Start global animation
    function startGlobalAnimation() {
      globalAnimationStartTime = Date.now();
      isGlobalAnimationRunning = true;
      console.log("Global animation started");
    }

    // Initialize all components for global timing (synchronized)
    orbit1.initializeForGlobalTiming();
    orbit2.initializeForGlobalTiming();
    // animatedParticleSystem.initializeForGlobalTiming();

    // Start the global animation system
    startGlobalAnimation();

    // Track last stage for cloned cards visibility
    let lastStageForCards = "idle";
    let showCardsTimeout: number | null = null;

    // Function to update cloned cards visibility
    function updateClonedCardsVisibility(stage: AnimationStage) {
      const container = document.getElementById("cloned-cards-container");
      if (!container) return;

      const cards = container.querySelectorAll(".cloned-card");

      if (stage === "stage4") {
        // Wait 500ms before showing cards after stage4 starts
        showCardsTimeout = window.setTimeout(() => {
          container.classList.remove("opacity-0");
          container.classList.add("opacity-100");
          // Show cards with staggered animation - emerging from behind the blob
          cards.forEach((card) => {
            // Reset transition delay to use HTML defaults (0ms, 100ms, 200ms)
            (card as HTMLElement).style.transitionDelay = '';
            card.classList.remove("translate-y-20", "scale-75", "opacity-0");
            card.classList.add("translate-y-0", "scale-100", "opacity-100");
          });
        }, 500);
      } else if (lastStageForCards === "stage4" && stage === "returning") {
        // Cancel pending show animation if any
        if (showCardsTimeout !== null) {
          window.clearTimeout(showCardsTimeout);
          showCardsTimeout = null;
        }
        // Hide cards when leaving stage4 - going back into the blob (in reverse order)
        cards.forEach((card, index) => {
          // Apply inverted delay: last card exits first (200ms, 100ms, 0ms)
          const invertedDelay = (cards.length - 1 - index) * 100;
          (card as HTMLElement).style.transitionDelay = `${invertedDelay}ms`;
          card.classList.remove("translate-y-0", "opacity-100");
          card.classList.add("translate-y-20", "opacity-0");
        });
        setTimeout(() => {
          container.classList.remove("opacity-100");
          container.classList.add("opacity-0");
        }, 400);
      } else if (stage !== "stage4") {
        // Cancel pending show animation if any
        if (showCardsTimeout !== null) {
          window.clearTimeout(showCardsTimeout);
          showCardsTimeout = null;
        }
        // Ensure container is hidden when not in stage4
        container.classList.remove("opacity-100");
        container.classList.add("opacity-0");
        cards.forEach((card, index) => {
          // Apply inverted delay for consistency
          const invertedDelay = (cards.length - 1 - index) * 100;
          (card as HTMLElement).style.transitionDelay = `${invertedDelay}ms`;
          card.classList.remove("translate-y-0", "opacity-100");
          card.classList.add("translate-y-20", "opacity-0");
        });
      }

      lastStageForCards = stage;
    }

    // Animation state management
    const pauseAnimation = () => {
      if (animationFrameId !== null) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
      currentAnimationState = 'paused';
      console.log('ðŸ”´ Animation paused - out of viewport');
    };

    const resumeAnimation = () => {
      if (animationFrameId === null && isInViewport) {
        currentAnimationState = 'active';
        console.log('ðŸŸ¢ Animation resumed - in viewport');
        animationFrameId = requestAnimationFrame(animate);
      }
    };

    // Animation loop
    let lastTime = 0;
    const animate = (currentTime: number) => {
      if (currentAnimationState === 'paused' || !isInViewport) {
        animationFrameId = null;
        return;
      }

      const deltaTime = (currentTime - lastTime) / 1000;
      lastTime = currentTime;

      // Calculate global elapsed time
      const globalElapsed = (Date.now() - globalAnimationStartTime) / 1000;
      const globalStage = getCurrentGlobalStage(globalElapsed);

      // Update cloned cards visibility based on stage
      updateClonedCardsVisibility(globalStage);

      // Update all systems with global timing
      animatedParticleSystem.update(deltaTime, globalElapsed, globalStage);
      orbit1.update(deltaTime, globalElapsed, globalStage);
      orbit2.update(deltaTime, globalElapsed, globalStage);

      // Render orbits (background layer)
      orbitRenderer.render(orbitScene, camera);

      // Render blob with lens effects (foreground layer)
      animatedParticleSystem.render(blobRenderer, camera, blobScene);

      // Continue animation loop only if still in viewport
      if (isInViewport && currentAnimationState === 'active') {
        animationFrameId = requestAnimationFrame(animate);
      } else {
        animationFrameId = null;
      }
    };

    // Intersection Observer for viewport detection
    const createViewportObserver = () => {
      const observer = new IntersectionObserver(
        (entries) => {
          const entry = entries[0];
          const wasInViewport = isInViewport;
          isInViewport = entry.isIntersecting;

          if (!wasInViewport && isInViewport) {
            // Reset animation completely
            globalAnimationStartTime = Date.now();
            lastTime = 0; // Reset lastTime to prevent huge deltaTime on first frame

            // Reset orbit rotations to initial positions
            const orbit1Rotation = 0.55 * Math.PI;
            const orbit2Rotation = 0.4 * Math.PI;

            orbit1.getGroup().rotation.z = orbit1Rotation;
            orbit2.getGroup().rotation.z = orbit2Rotation;

            console.log('ðŸ”„ Reset orbits - orbit1:', orbit1Rotation, 'orbit2:', orbit2Rotation);

            currentAnimationState = 'entering';
            console.log('ðŸ‘€ Entering viewport - resetting animation from start');
            resumeAnimation();
          } else if (wasInViewport && !isInViewport) {
            // Leaving viewport
            currentAnimationState = 'leaving';
            console.log('ðŸ‘‹ Leaving viewport - pausing animation');
            pauseAnimation();
          }
        },
        {
          threshold: 0.1, // Trigger when 10% of element is visible
          rootMargin: '50px' // Start animation 50px before element enters viewport
        }
      );

      observer.observe(container);
      return observer;
    };

    const viewportObserver = createViewportObserver();

    console.log("ðŸš€ Orbit system initialized - waiting for viewport...");
    // Animation will start when element enters viewport

    // Handle resize with debouncing
    let resizeTimeout: ReturnType<typeof setTimeout> | null = null;
    const handleResize = () => {
      if (resizeTimeout) {
        clearTimeout(resizeTimeout);
      }
      
      resizeTimeout = setTimeout(() => {
        const newWidth = container.clientWidth;
        const newHeight = container.clientHeight;

        camera.aspect = newWidth / newHeight;
        camera.updateProjectionMatrix();

        orbitRenderer.setSize(newWidth, newHeight);
        orbitRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        blobRenderer.setSize(newWidth, newHeight);
        blobRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        resizeTimeout = null;
      }, 100);
    };

    // Add resize listener
    window.addEventListener("resize", handleResize);

    // Cleanup function for when component unmounts
    const cleanup = () => {
      // Stop animation loop
      if (animationFrameId !== null) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }

      // Disconnect viewport observer
      viewportObserver.disconnect();

      // Clear resize timeout
      if (resizeTimeout) {
        clearTimeout(resizeTimeout);
      }

      // Remove event listeners
      window.removeEventListener("resize", handleResize);

      // Dispose of Three.js objects
      animatedParticleSystem.dispose();
      orbit1.dispose();
      orbit2.dispose();

      // Dispose renderers
      orbitRenderer.dispose();
      blobRenderer.dispose();

      currentAnimationState = 'idle';
      isInViewport = false;

      console.log("ðŸ§¹ Orbit system cleaned up");
    };

    // Store cleanup function for potential use
    (window as any).orbitSystemCleanup = cleanup;

    console.log("ðŸŽ¯ Orbit System fully initialized and running!");
  };

  // Initialize when DOM is ready
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initOrbitSystem);
  } else {
    initOrbitSystem();
  }
</script>
